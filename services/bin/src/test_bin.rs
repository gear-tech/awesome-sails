// Code generated by sails-client-gen. DO NOT EDIT.
#[allow(unused_imports)]
use sails_rs::collections::BTreeMap;
#[allow(unused_imports)]
use sails_rs::{
    String,
    calls::{Activation, Call, Query, Remoting, RemotingAction},
    prelude::*,
};
pub struct TestBinFactory<R> {
    #[allow(dead_code)]
    remoting: R,
}
impl<R> TestBinFactory<R> {
    #[allow(unused)]
    pub fn new(remoting: R) -> Self {
        Self { remoting }
    }
}
impl<R: Remoting + Clone> traits::TestBinFactory for TestBinFactory<R> {
    type Args = R::Args;
    fn new(&self) -> impl Activation<Args = R::Args> {
        RemotingAction::<_, test_bin_factory::io::New>::new(self.remoting.clone(), ())
    }
}

pub mod test_bin_factory {
    use super::*;
    pub mod io {
        use super::*;
        use sails_rs::calls::ActionIo;
        pub struct New(());
        impl New {
            #[allow(dead_code)]
            pub fn encode_call() -> Vec<u8> {
                <New as ActionIo>::encode_call(&())
            }
        }
        impl ActionIo for New {
            const ROUTE: &'static [u8] = &[12, 78, 101, 119];
            type Params = ();
            type Reply = ();
        }
    }
}
pub struct Test<R> {
    remoting: R,
}
impl<R> Test<R> {
    pub fn new(remoting: R) -> Self {
        Self { remoting }
    }
}
impl<R: Remoting + Clone> traits::Test for Test<R> {
    type Args = R::Args;
    fn set(
        &mut self,
        new_allowances: Vec<(ActorId, ActorId, U256, u32)>,
        new_balances: Vec<(ActorId, U256)>,
        minimum_balance: U256,
        expiry_period: u32,
    ) -> impl Call<Output = (), Args = R::Args> {
        RemotingAction::<_, test::io::Set>::new(
            self.remoting.clone(),
            (new_allowances, new_balances, minimum_balance, expiry_period),
        )
    }
}

pub mod test {
    use super::*;

    pub mod io {
        use super::*;
        use sails_rs::calls::ActionIo;
        pub struct Set(());
        impl Set {
            #[allow(dead_code)]
            pub fn encode_call(
                new_allowances: Vec<(ActorId, ActorId, U256, u32)>,
                new_balances: Vec<(ActorId, U256)>,
                minimum_balance: U256,
                expiry_period: u32,
            ) -> Vec<u8> {
                <Set as ActionIo>::encode_call(&(
                    new_allowances,
                    new_balances,
                    minimum_balance,
                    expiry_period,
                ))
            }
        }
        impl ActionIo for Set {
            const ROUTE: &'static [u8] = &[16, 84, 101, 115, 116, 12, 83, 101, 116];
            type Params = (
                Vec<(ActorId, ActorId, U256, u32)>,
                Vec<(ActorId, U256)>,
                U256,
                u32,
            );
            type Reply = ();
        }
    }
}
pub struct Vft<R> {
    remoting: R,
}
impl<R> Vft<R> {
    pub fn new(remoting: R) -> Self {
        Self { remoting }
    }
}
impl<R: Remoting + Clone> traits::Vft for Vft<R> {
    type Args = R::Args;
    fn approve(
        &mut self,
        spender: ActorId,
        value: U256,
    ) -> impl Call<Output = bool, Args = R::Args> {
        RemotingAction::<_, vft::io::Approve>::new(self.remoting.clone(), (spender, value))
    }
    fn transfer(&mut self, to: ActorId, value: U256) -> impl Call<Output = bool, Args = R::Args> {
        RemotingAction::<_, vft::io::Transfer>::new(self.remoting.clone(), (to, value))
    }
    fn transfer_from(
        &mut self,
        from: ActorId,
        to: ActorId,
        value: U256,
    ) -> impl Call<Output = bool, Args = R::Args> {
        RemotingAction::<_, vft::io::TransferFrom>::new(self.remoting.clone(), (from, to, value))
    }
    fn allowance(
        &self,
        owner: ActorId,
        spender: ActorId,
    ) -> impl Query<Output = U256, Args = R::Args> {
        RemotingAction::<_, vft::io::Allowance>::new(self.remoting.clone(), (owner, spender))
    }
    fn balance_of(&self, account: ActorId) -> impl Query<Output = U256, Args = R::Args> {
        RemotingAction::<_, vft::io::BalanceOf>::new(self.remoting.clone(), account)
    }
    fn total_supply(&self) -> impl Query<Output = U256, Args = R::Args> {
        RemotingAction::<_, vft::io::TotalSupply>::new(self.remoting.clone(), ())
    }
}

pub mod vft {
    use super::*;

    pub mod io {
        use super::*;
        use sails_rs::calls::ActionIo;
        pub struct Approve(());
        impl Approve {
            #[allow(dead_code)]
            pub fn encode_call(spender: ActorId, value: U256) -> Vec<u8> {
                <Approve as ActionIo>::encode_call(&(spender, value))
            }
        }
        impl ActionIo for Approve {
            const ROUTE: &'static [u8] = &[12, 86, 102, 116, 28, 65, 112, 112, 114, 111, 118, 101];
            type Params = (ActorId, U256);
            type Reply = bool;
        }
        pub struct Transfer(());
        impl Transfer {
            #[allow(dead_code)]
            pub fn encode_call(to: ActorId, value: U256) -> Vec<u8> {
                <Transfer as ActionIo>::encode_call(&(to, value))
            }
        }
        impl ActionIo for Transfer {
            const ROUTE: &'static [u8] =
                &[12, 86, 102, 116, 32, 84, 114, 97, 110, 115, 102, 101, 114];
            type Params = (ActorId, U256);
            type Reply = bool;
        }
        pub struct TransferFrom(());
        impl TransferFrom {
            #[allow(dead_code)]
            pub fn encode_call(from: ActorId, to: ActorId, value: U256) -> Vec<u8> {
                <TransferFrom as ActionIo>::encode_call(&(from, to, value))
            }
        }
        impl ActionIo for TransferFrom {
            const ROUTE: &'static [u8] = &[
                12, 86, 102, 116, 48, 84, 114, 97, 110, 115, 102, 101, 114, 70, 114, 111, 109,
            ];
            type Params = (ActorId, ActorId, U256);
            type Reply = bool;
        }
        pub struct Allowance(());
        impl Allowance {
            #[allow(dead_code)]
            pub fn encode_call(owner: ActorId, spender: ActorId) -> Vec<u8> {
                <Allowance as ActionIo>::encode_call(&(owner, spender))
            }
        }
        impl ActionIo for Allowance {
            const ROUTE: &'static [u8] = &[
                12, 86, 102, 116, 36, 65, 108, 108, 111, 119, 97, 110, 99, 101,
            ];
            type Params = (ActorId, ActorId);
            type Reply = U256;
        }
        pub struct BalanceOf(());
        impl BalanceOf {
            #[allow(dead_code)]
            pub fn encode_call(account: ActorId) -> Vec<u8> {
                <BalanceOf as ActionIo>::encode_call(&account)
            }
        }
        impl ActionIo for BalanceOf {
            const ROUTE: &'static [u8] =
                &[12, 86, 102, 116, 36, 66, 97, 108, 97, 110, 99, 101, 79, 102];
            type Params = ActorId;
            type Reply = U256;
        }
        pub struct TotalSupply(());
        impl TotalSupply {
            #[allow(dead_code)]
            pub fn encode_call() -> Vec<u8> {
                <TotalSupply as ActionIo>::encode_call(&())
            }
        }
        impl ActionIo for TotalSupply {
            const ROUTE: &'static [u8] = &[
                12, 86, 102, 116, 44, 84, 111, 116, 97, 108, 83, 117, 112, 112, 108, 121,
            ];
            type Params = ();
            type Reply = U256;
        }
    }

    #[allow(dead_code)]
    #[cfg(not(target_arch = "wasm32"))]
    pub mod events {
        use super::*;
        use sails_rs::events::*;
        #[derive(PartialEq, Debug, Encode, Decode)]
        #[codec(crate = sails_rs::scale_codec)]
        pub enum VftEvents {
            Approval {
                owner: ActorId,
                spender: ActorId,
                value: U256,
            },
            Transfer {
                from: ActorId,
                to: ActorId,
                value: U256,
            },
        }
        impl EventIo for VftEvents {
            const ROUTE: &'static [u8] = &[12, 86, 102, 116];
            const EVENT_NAMES: &'static [&'static [u8]] = &[
                &[32, 65, 112, 112, 114, 111, 118, 97, 108],
                &[32, 84, 114, 97, 110, 115, 102, 101, 114],
            ];
            type Event = Self;
        }
        pub fn listener<R: Listener<Vec<u8>>>(remoting: R) -> impl Listener<VftEvents> {
            RemotingListener::<_, VftEvents>::new(remoting)
        }
    }
}
pub struct VftAdmin<R> {
    remoting: R,
}
impl<R> VftAdmin<R> {
    pub fn new(remoting: R) -> Self {
        Self { remoting }
    }
}
impl<R: Remoting + Clone> traits::VftAdmin for VftAdmin<R> {
    type Args = R::Args;
    fn append_allowances_shard(&mut self, capacity: u32) -> impl Call<Output = (), Args = R::Args> {
        RemotingAction::<_, vft_admin::io::AppendAllowancesShard>::new(
            self.remoting.clone(),
            capacity,
        )
    }
    fn append_balances_shard(&mut self, capacity: u32) -> impl Call<Output = (), Args = R::Args> {
        RemotingAction::<_, vft_admin::io::AppendBalancesShard>::new(
            self.remoting.clone(),
            capacity,
        )
    }
    fn approve_from(
        &mut self,
        owner: ActorId,
        spender: ActorId,
        value: U256,
    ) -> impl Call<Output = bool, Args = R::Args> {
        RemotingAction::<_, vft_admin::io::ApproveFrom>::new(
            self.remoting.clone(),
            (owner, spender, value),
        )
    }
    fn burn(&mut self, from: ActorId, value: U256) -> impl Call<Output = (), Args = R::Args> {
        RemotingAction::<_, vft_admin::io::Burn>::new(self.remoting.clone(), (from, value))
    }
    fn exit(&mut self, inheritor: ActorId) -> impl Call<Output = (), Args = R::Args> {
        RemotingAction::<_, vft_admin::io::Exit>::new(self.remoting.clone(), inheritor)
    }
    fn mint(&mut self, to: ActorId, value: U256) -> impl Call<Output = (), Args = R::Args> {
        RemotingAction::<_, vft_admin::io::Mint>::new(self.remoting.clone(), (to, value))
    }
    fn pause(&mut self) -> impl Call<Output = (), Args = R::Args> {
        RemotingAction::<_, vft_admin::io::Pause>::new(self.remoting.clone(), ())
    }
    fn resume(&mut self) -> impl Call<Output = (), Args = R::Args> {
        RemotingAction::<_, vft_admin::io::Resume>::new(self.remoting.clone(), ())
    }
    fn set_admin(&mut self, admin: ActorId) -> impl Call<Output = (), Args = R::Args> {
        RemotingAction::<_, vft_admin::io::SetAdmin>::new(self.remoting.clone(), admin)
    }
    fn set_burner(&mut self, burner: ActorId) -> impl Call<Output = (), Args = R::Args> {
        RemotingAction::<_, vft_admin::io::SetBurner>::new(self.remoting.clone(), burner)
    }
    fn set_expiry_period(&mut self, period: u32) -> impl Call<Output = (), Args = R::Args> {
        RemotingAction::<_, vft_admin::io::SetExpiryPeriod>::new(self.remoting.clone(), period)
    }
    fn set_minimum_balance(&mut self, value: U256) -> impl Call<Output = (), Args = R::Args> {
        RemotingAction::<_, vft_admin::io::SetMinimumBalance>::new(self.remoting.clone(), value)
    }
    fn set_minter(&mut self, minter: ActorId) -> impl Call<Output = (), Args = R::Args> {
        RemotingAction::<_, vft_admin::io::SetMinter>::new(self.remoting.clone(), minter)
    }
    fn set_pauser(&mut self, pauser: ActorId) -> impl Call<Output = (), Args = R::Args> {
        RemotingAction::<_, vft_admin::io::SetPauser>::new(self.remoting.clone(), pauser)
    }
    fn admin(&self) -> impl Query<Output = ActorId, Args = R::Args> {
        RemotingAction::<_, vft_admin::io::Admin>::new(self.remoting.clone(), ())
    }
    fn burner(&self) -> impl Query<Output = ActorId, Args = R::Args> {
        RemotingAction::<_, vft_admin::io::Burner>::new(self.remoting.clone(), ())
    }
    fn is_paused(&self) -> impl Query<Output = bool, Args = R::Args> {
        RemotingAction::<_, vft_admin::io::IsPaused>::new(self.remoting.clone(), ())
    }
    fn minter(&self) -> impl Query<Output = ActorId, Args = R::Args> {
        RemotingAction::<_, vft_admin::io::Minter>::new(self.remoting.clone(), ())
    }
    fn pauser(&self) -> impl Query<Output = ActorId, Args = R::Args> {
        RemotingAction::<_, vft_admin::io::Pauser>::new(self.remoting.clone(), ())
    }
}

pub mod vft_admin {
    use super::*;

    pub mod io {
        use super::*;
        use sails_rs::calls::ActionIo;
        pub struct AppendAllowancesShard(());
        impl AppendAllowancesShard {
            #[allow(dead_code)]
            pub fn encode_call(capacity: u32) -> Vec<u8> {
                <AppendAllowancesShard as ActionIo>::encode_call(&capacity)
            }
        }
        impl ActionIo for AppendAllowancesShard {
            const ROUTE: &'static [u8] = &[
                32, 86, 102, 116, 65, 100, 109, 105, 110, 84, 65, 112, 112, 101, 110, 100, 65, 108,
                108, 111, 119, 97, 110, 99, 101, 115, 83, 104, 97, 114, 100,
            ];
            type Params = u32;
            type Reply = ();
        }
        pub struct AppendBalancesShard(());
        impl AppendBalancesShard {
            #[allow(dead_code)]
            pub fn encode_call(capacity: u32) -> Vec<u8> {
                <AppendBalancesShard as ActionIo>::encode_call(&capacity)
            }
        }
        impl ActionIo for AppendBalancesShard {
            const ROUTE: &'static [u8] = &[
                32, 86, 102, 116, 65, 100, 109, 105, 110, 76, 65, 112, 112, 101, 110, 100, 66, 97,
                108, 97, 110, 99, 101, 115, 83, 104, 97, 114, 100,
            ];
            type Params = u32;
            type Reply = ();
        }
        pub struct ApproveFrom(());
        impl ApproveFrom {
            #[allow(dead_code)]
            pub fn encode_call(owner: ActorId, spender: ActorId, value: U256) -> Vec<u8> {
                <ApproveFrom as ActionIo>::encode_call(&(owner, spender, value))
            }
        }
        impl ActionIo for ApproveFrom {
            const ROUTE: &'static [u8] = &[
                32, 86, 102, 116, 65, 100, 109, 105, 110, 44, 65, 112, 112, 114, 111, 118, 101, 70,
                114, 111, 109,
            ];
            type Params = (ActorId, ActorId, U256);
            type Reply = bool;
        }
        pub struct Burn(());
        impl Burn {
            #[allow(dead_code)]
            pub fn encode_call(from: ActorId, value: U256) -> Vec<u8> {
                <Burn as ActionIo>::encode_call(&(from, value))
            }
        }
        impl ActionIo for Burn {
            const ROUTE: &'static [u8] = &[
                32, 86, 102, 116, 65, 100, 109, 105, 110, 16, 66, 117, 114, 110,
            ];
            type Params = (ActorId, U256);
            type Reply = ();
        }
        pub struct Exit(());
        impl Exit {
            #[allow(dead_code)]
            pub fn encode_call(inheritor: ActorId) -> Vec<u8> {
                <Exit as ActionIo>::encode_call(&inheritor)
            }
        }
        impl ActionIo for Exit {
            const ROUTE: &'static [u8] = &[
                32, 86, 102, 116, 65, 100, 109, 105, 110, 16, 69, 120, 105, 116,
            ];
            type Params = ActorId;
            type Reply = ();
        }
        pub struct Mint(());
        impl Mint {
            #[allow(dead_code)]
            pub fn encode_call(to: ActorId, value: U256) -> Vec<u8> {
                <Mint as ActionIo>::encode_call(&(to, value))
            }
        }
        impl ActionIo for Mint {
            const ROUTE: &'static [u8] = &[
                32, 86, 102, 116, 65, 100, 109, 105, 110, 16, 77, 105, 110, 116,
            ];
            type Params = (ActorId, U256);
            type Reply = ();
        }
        pub struct Pause(());
        impl Pause {
            #[allow(dead_code)]
            pub fn encode_call() -> Vec<u8> {
                <Pause as ActionIo>::encode_call(&())
            }
        }
        impl ActionIo for Pause {
            const ROUTE: &'static [u8] = &[
                32, 86, 102, 116, 65, 100, 109, 105, 110, 20, 80, 97, 117, 115, 101,
            ];
            type Params = ();
            type Reply = ();
        }
        pub struct Resume(());
        impl Resume {
            #[allow(dead_code)]
            pub fn encode_call() -> Vec<u8> {
                <Resume as ActionIo>::encode_call(&())
            }
        }
        impl ActionIo for Resume {
            const ROUTE: &'static [u8] = &[
                32, 86, 102, 116, 65, 100, 109, 105, 110, 24, 82, 101, 115, 117, 109, 101,
            ];
            type Params = ();
            type Reply = ();
        }
        pub struct SetAdmin(());
        impl SetAdmin {
            #[allow(dead_code)]
            pub fn encode_call(admin: ActorId) -> Vec<u8> {
                <SetAdmin as ActionIo>::encode_call(&admin)
            }
        }
        impl ActionIo for SetAdmin {
            const ROUTE: &'static [u8] = &[
                32, 86, 102, 116, 65, 100, 109, 105, 110, 32, 83, 101, 116, 65, 100, 109, 105, 110,
            ];
            type Params = ActorId;
            type Reply = ();
        }
        pub struct SetBurner(());
        impl SetBurner {
            #[allow(dead_code)]
            pub fn encode_call(burner: ActorId) -> Vec<u8> {
                <SetBurner as ActionIo>::encode_call(&burner)
            }
        }
        impl ActionIo for SetBurner {
            const ROUTE: &'static [u8] = &[
                32, 86, 102, 116, 65, 100, 109, 105, 110, 36, 83, 101, 116, 66, 117, 114, 110, 101,
                114,
            ];
            type Params = ActorId;
            type Reply = ();
        }
        pub struct SetExpiryPeriod(());
        impl SetExpiryPeriod {
            #[allow(dead_code)]
            pub fn encode_call(period: u32) -> Vec<u8> {
                <SetExpiryPeriod as ActionIo>::encode_call(&period)
            }
        }
        impl ActionIo for SetExpiryPeriod {
            const ROUTE: &'static [u8] = &[
                32, 86, 102, 116, 65, 100, 109, 105, 110, 60, 83, 101, 116, 69, 120, 112, 105, 114,
                121, 80, 101, 114, 105, 111, 100,
            ];
            type Params = u32;
            type Reply = ();
        }
        pub struct SetMinimumBalance(());
        impl SetMinimumBalance {
            #[allow(dead_code)]
            pub fn encode_call(value: U256) -> Vec<u8> {
                <SetMinimumBalance as ActionIo>::encode_call(&value)
            }
        }
        impl ActionIo for SetMinimumBalance {
            const ROUTE: &'static [u8] = &[
                32, 86, 102, 116, 65, 100, 109, 105, 110, 68, 83, 101, 116, 77, 105, 110, 105, 109,
                117, 109, 66, 97, 108, 97, 110, 99, 101,
            ];
            type Params = U256;
            type Reply = ();
        }
        pub struct SetMinter(());
        impl SetMinter {
            #[allow(dead_code)]
            pub fn encode_call(minter: ActorId) -> Vec<u8> {
                <SetMinter as ActionIo>::encode_call(&minter)
            }
        }
        impl ActionIo for SetMinter {
            const ROUTE: &'static [u8] = &[
                32, 86, 102, 116, 65, 100, 109, 105, 110, 36, 83, 101, 116, 77, 105, 110, 116, 101,
                114,
            ];
            type Params = ActorId;
            type Reply = ();
        }
        pub struct SetPauser(());
        impl SetPauser {
            #[allow(dead_code)]
            pub fn encode_call(pauser: ActorId) -> Vec<u8> {
                <SetPauser as ActionIo>::encode_call(&pauser)
            }
        }
        impl ActionIo for SetPauser {
            const ROUTE: &'static [u8] = &[
                32, 86, 102, 116, 65, 100, 109, 105, 110, 36, 83, 101, 116, 80, 97, 117, 115, 101,
                114,
            ];
            type Params = ActorId;
            type Reply = ();
        }
        pub struct Admin(());
        impl Admin {
            #[allow(dead_code)]
            pub fn encode_call() -> Vec<u8> {
                <Admin as ActionIo>::encode_call(&())
            }
        }
        impl ActionIo for Admin {
            const ROUTE: &'static [u8] = &[
                32, 86, 102, 116, 65, 100, 109, 105, 110, 20, 65, 100, 109, 105, 110,
            ];
            type Params = ();
            type Reply = ActorId;
        }
        pub struct Burner(());
        impl Burner {
            #[allow(dead_code)]
            pub fn encode_call() -> Vec<u8> {
                <Burner as ActionIo>::encode_call(&())
            }
        }
        impl ActionIo for Burner {
            const ROUTE: &'static [u8] = &[
                32, 86, 102, 116, 65, 100, 109, 105, 110, 24, 66, 117, 114, 110, 101, 114,
            ];
            type Params = ();
            type Reply = ActorId;
        }
        pub struct IsPaused(());
        impl IsPaused {
            #[allow(dead_code)]
            pub fn encode_call() -> Vec<u8> {
                <IsPaused as ActionIo>::encode_call(&())
            }
        }
        impl ActionIo for IsPaused {
            const ROUTE: &'static [u8] = &[
                32, 86, 102, 116, 65, 100, 109, 105, 110, 32, 73, 115, 80, 97, 117, 115, 101, 100,
            ];
            type Params = ();
            type Reply = bool;
        }
        pub struct Minter(());
        impl Minter {
            #[allow(dead_code)]
            pub fn encode_call() -> Vec<u8> {
                <Minter as ActionIo>::encode_call(&())
            }
        }
        impl ActionIo for Minter {
            const ROUTE: &'static [u8] = &[
                32, 86, 102, 116, 65, 100, 109, 105, 110, 24, 77, 105, 110, 116, 101, 114,
            ];
            type Params = ();
            type Reply = ActorId;
        }
        pub struct Pauser(());
        impl Pauser {
            #[allow(dead_code)]
            pub fn encode_call() -> Vec<u8> {
                <Pauser as ActionIo>::encode_call(&())
            }
        }
        impl ActionIo for Pauser {
            const ROUTE: &'static [u8] = &[
                32, 86, 102, 116, 65, 100, 109, 105, 110, 24, 80, 97, 117, 115, 101, 114,
            ];
            type Params = ();
            type Reply = ActorId;
        }
    }

    #[allow(dead_code)]
    #[cfg(not(target_arch = "wasm32"))]
    pub mod events {
        use super::*;
        use sails_rs::events::*;
        #[derive(PartialEq, Debug, Encode, Decode)]
        #[codec(crate = sails_rs::scale_codec)]
        pub enum VftAdminEvents {
            AdminChanged(ActorId),
            BurnerChanged(ActorId),
            MinterChanged(ActorId),
            PauserChanged(ActorId),
            BurnerTookPlace,
            MinterTookPlace,
            ExpiryPeriodChanged(u32),
            MinimumBalanceChanged(U256),
            Exited(ActorId),
            Paused,
            Resumed,
        }
        impl EventIo for VftAdminEvents {
            const ROUTE: &'static [u8] = &[32, 86, 102, 116, 65, 100, 109, 105, 110];
            const EVENT_NAMES: &'static [&'static [u8]] = &[
                &[48, 65, 100, 109, 105, 110, 67, 104, 97, 110, 103, 101, 100],
                &[
                    52, 66, 117, 114, 110, 101, 114, 67, 104, 97, 110, 103, 101, 100,
                ],
                &[
                    52, 77, 105, 110, 116, 101, 114, 67, 104, 97, 110, 103, 101, 100,
                ],
                &[
                    52, 80, 97, 117, 115, 101, 114, 67, 104, 97, 110, 103, 101, 100,
                ],
                &[
                    60, 66, 117, 114, 110, 101, 114, 84, 111, 111, 107, 80, 108, 97, 99, 101,
                ],
                &[
                    60, 77, 105, 110, 116, 101, 114, 84, 111, 111, 107, 80, 108, 97, 99, 101,
                ],
                &[
                    76, 69, 120, 112, 105, 114, 121, 80, 101, 114, 105, 111, 100, 67, 104, 97, 110,
                    103, 101, 100,
                ],
                &[
                    84, 77, 105, 110, 105, 109, 117, 109, 66, 97, 108, 97, 110, 99, 101, 67, 104,
                    97, 110, 103, 101, 100,
                ],
                &[24, 69, 120, 105, 116, 101, 100],
                &[24, 80, 97, 117, 115, 101, 100],
                &[28, 82, 101, 115, 117, 109, 101, 100],
            ];
            type Event = Self;
        }
        pub fn listener<R: Listener<Vec<u8>>>(remoting: R) -> impl Listener<VftAdminEvents> {
            RemotingListener::<_, VftAdminEvents>::new(remoting)
        }
    }
}
pub struct VftExtension<R> {
    remoting: R,
}
impl<R> VftExtension<R> {
    pub fn new(remoting: R) -> Self {
        Self { remoting }
    }
}
impl<R: Remoting + Clone> traits::VftExtension for VftExtension<R> {
    type Args = R::Args;
    fn allocate_next_allowances_shard(&mut self) -> impl Call<Output = bool, Args = R::Args> {
        RemotingAction::<_, vft_extension::io::AllocateNextAllowancesShard>::new(
            self.remoting.clone(),
            (),
        )
    }
    fn allocate_next_balances_shard(&mut self) -> impl Call<Output = bool, Args = R::Args> {
        RemotingAction::<_, vft_extension::io::AllocateNextBalancesShard>::new(
            self.remoting.clone(),
            (),
        )
    }
    fn remove_expired_allowance(
        &mut self,
        owner: ActorId,
        spender: ActorId,
    ) -> impl Call<Output = bool, Args = R::Args> {
        RemotingAction::<_, vft_extension::io::RemoveExpiredAllowance>::new(
            self.remoting.clone(),
            (owner, spender),
        )
    }
    fn transfer_all(&mut self, to: ActorId) -> impl Call<Output = bool, Args = R::Args> {
        RemotingAction::<_, vft_extension::io::TransferAll>::new(self.remoting.clone(), to)
    }
    fn transfer_all_from(
        &mut self,
        from: ActorId,
        to: ActorId,
    ) -> impl Call<Output = bool, Args = R::Args> {
        RemotingAction::<_, vft_extension::io::TransferAllFrom>::new(
            self.remoting.clone(),
            (from, to),
        )
    }
    fn allowance_of(
        &self,
        owner: ActorId,
        spender: ActorId,
    ) -> impl Query<Output = Option<(U256, u32)>, Args = R::Args> {
        RemotingAction::<_, vft_extension::io::AllowanceOf>::new(
            self.remoting.clone(),
            (owner, spender),
        )
    }
    fn allowances(
        &self,
        cursor: u32,
        len: u32,
    ) -> impl Query<Output = Vec<((ActorId, ActorId), (U256, u32))>, Args = R::Args> {
        RemotingAction::<_, vft_extension::io::Allowances>::new(
            self.remoting.clone(),
            (cursor, len),
        )
    }
    fn balance_of(&self, account: ActorId) -> impl Query<Output = Option<U256>, Args = R::Args> {
        RemotingAction::<_, vft_extension::io::BalanceOf>::new(self.remoting.clone(), account)
    }
    fn balances(
        &self,
        cursor: u32,
        len: u32,
    ) -> impl Query<Output = Vec<(ActorId, U256)>, Args = R::Args> {
        RemotingAction::<_, vft_extension::io::Balances>::new(self.remoting.clone(), (cursor, len))
    }
    fn expiry_period(&self) -> impl Query<Output = u32, Args = R::Args> {
        RemotingAction::<_, vft_extension::io::ExpiryPeriod>::new(self.remoting.clone(), ())
    }
    fn minimum_balance(&self) -> impl Query<Output = U256, Args = R::Args> {
        RemotingAction::<_, vft_extension::io::MinimumBalance>::new(self.remoting.clone(), ())
    }
    fn unused_value(&self) -> impl Query<Output = U256, Args = R::Args> {
        RemotingAction::<_, vft_extension::io::UnusedValue>::new(self.remoting.clone(), ())
    }
}

pub mod vft_extension {
    use super::*;

    pub mod io {
        use super::*;
        use sails_rs::calls::ActionIo;
        pub struct AllocateNextAllowancesShard(());
        impl AllocateNextAllowancesShard {
            #[allow(dead_code)]
            pub fn encode_call() -> Vec<u8> {
                <AllocateNextAllowancesShard as ActionIo>::encode_call(&())
            }
        }
        impl ActionIo for AllocateNextAllowancesShard {
            const ROUTE: &'static [u8] = &[
                48, 86, 102, 116, 69, 120, 116, 101, 110, 115, 105, 111, 110, 108, 65, 108, 108,
                111, 99, 97, 116, 101, 78, 101, 120, 116, 65, 108, 108, 111, 119, 97, 110, 99, 101,
                115, 83, 104, 97, 114, 100,
            ];
            type Params = ();
            type Reply = bool;
        }
        pub struct AllocateNextBalancesShard(());
        impl AllocateNextBalancesShard {
            #[allow(dead_code)]
            pub fn encode_call() -> Vec<u8> {
                <AllocateNextBalancesShard as ActionIo>::encode_call(&())
            }
        }
        impl ActionIo for AllocateNextBalancesShard {
            const ROUTE: &'static [u8] = &[
                48, 86, 102, 116, 69, 120, 116, 101, 110, 115, 105, 111, 110, 100, 65, 108, 108,
                111, 99, 97, 116, 101, 78, 101, 120, 116, 66, 97, 108, 97, 110, 99, 101, 115, 83,
                104, 97, 114, 100,
            ];
            type Params = ();
            type Reply = bool;
        }
        pub struct RemoveExpiredAllowance(());
        impl RemoveExpiredAllowance {
            #[allow(dead_code)]
            pub fn encode_call(owner: ActorId, spender: ActorId) -> Vec<u8> {
                <RemoveExpiredAllowance as ActionIo>::encode_call(&(owner, spender))
            }
        }
        impl ActionIo for RemoveExpiredAllowance {
            const ROUTE: &'static [u8] = &[
                48, 86, 102, 116, 69, 120, 116, 101, 110, 115, 105, 111, 110, 88, 82, 101, 109,
                111, 118, 101, 69, 120, 112, 105, 114, 101, 100, 65, 108, 108, 111, 119, 97, 110,
                99, 101,
            ];
            type Params = (ActorId, ActorId);
            type Reply = bool;
        }
        pub struct TransferAll(());
        impl TransferAll {
            #[allow(dead_code)]
            pub fn encode_call(to: ActorId) -> Vec<u8> {
                <TransferAll as ActionIo>::encode_call(&to)
            }
        }
        impl ActionIo for TransferAll {
            const ROUTE: &'static [u8] = &[
                48, 86, 102, 116, 69, 120, 116, 101, 110, 115, 105, 111, 110, 44, 84, 114, 97, 110,
                115, 102, 101, 114, 65, 108, 108,
            ];
            type Params = ActorId;
            type Reply = bool;
        }
        pub struct TransferAllFrom(());
        impl TransferAllFrom {
            #[allow(dead_code)]
            pub fn encode_call(from: ActorId, to: ActorId) -> Vec<u8> {
                <TransferAllFrom as ActionIo>::encode_call(&(from, to))
            }
        }
        impl ActionIo for TransferAllFrom {
            const ROUTE: &'static [u8] = &[
                48, 86, 102, 116, 69, 120, 116, 101, 110, 115, 105, 111, 110, 60, 84, 114, 97, 110,
                115, 102, 101, 114, 65, 108, 108, 70, 114, 111, 109,
            ];
            type Params = (ActorId, ActorId);
            type Reply = bool;
        }
        pub struct AllowanceOf(());
        impl AllowanceOf {
            #[allow(dead_code)]
            pub fn encode_call(owner: ActorId, spender: ActorId) -> Vec<u8> {
                <AllowanceOf as ActionIo>::encode_call(&(owner, spender))
            }
        }
        impl ActionIo for AllowanceOf {
            const ROUTE: &'static [u8] = &[
                48, 86, 102, 116, 69, 120, 116, 101, 110, 115, 105, 111, 110, 44, 65, 108, 108,
                111, 119, 97, 110, 99, 101, 79, 102,
            ];
            type Params = (ActorId, ActorId);
            type Reply = Option<(U256, u32)>;
        }
        pub struct Allowances(());
        impl Allowances {
            #[allow(dead_code)]
            pub fn encode_call(cursor: u32, len: u32) -> Vec<u8> {
                <Allowances as ActionIo>::encode_call(&(cursor, len))
            }
        }
        impl ActionIo for Allowances {
            const ROUTE: &'static [u8] = &[
                48, 86, 102, 116, 69, 120, 116, 101, 110, 115, 105, 111, 110, 40, 65, 108, 108,
                111, 119, 97, 110, 99, 101, 115,
            ];
            type Params = (u32, u32);
            type Reply = Vec<((ActorId, ActorId), (U256, u32))>;
        }
        pub struct BalanceOf(());
        impl BalanceOf {
            #[allow(dead_code)]
            pub fn encode_call(account: ActorId) -> Vec<u8> {
                <BalanceOf as ActionIo>::encode_call(&account)
            }
        }
        impl ActionIo for BalanceOf {
            const ROUTE: &'static [u8] = &[
                48, 86, 102, 116, 69, 120, 116, 101, 110, 115, 105, 111, 110, 36, 66, 97, 108, 97,
                110, 99, 101, 79, 102,
            ];
            type Params = ActorId;
            type Reply = Option<U256>;
        }
        pub struct Balances(());
        impl Balances {
            #[allow(dead_code)]
            pub fn encode_call(cursor: u32, len: u32) -> Vec<u8> {
                <Balances as ActionIo>::encode_call(&(cursor, len))
            }
        }
        impl ActionIo for Balances {
            const ROUTE: &'static [u8] = &[
                48, 86, 102, 116, 69, 120, 116, 101, 110, 115, 105, 111, 110, 32, 66, 97, 108, 97,
                110, 99, 101, 115,
            ];
            type Params = (u32, u32);
            type Reply = Vec<(ActorId, U256)>;
        }
        pub struct ExpiryPeriod(());
        impl ExpiryPeriod {
            #[allow(dead_code)]
            pub fn encode_call() -> Vec<u8> {
                <ExpiryPeriod as ActionIo>::encode_call(&())
            }
        }
        impl ActionIo for ExpiryPeriod {
            const ROUTE: &'static [u8] = &[
                48, 86, 102, 116, 69, 120, 116, 101, 110, 115, 105, 111, 110, 48, 69, 120, 112,
                105, 114, 121, 80, 101, 114, 105, 111, 100,
            ];
            type Params = ();
            type Reply = u32;
        }
        pub struct MinimumBalance(());
        impl MinimumBalance {
            #[allow(dead_code)]
            pub fn encode_call() -> Vec<u8> {
                <MinimumBalance as ActionIo>::encode_call(&())
            }
        }
        impl ActionIo for MinimumBalance {
            const ROUTE: &'static [u8] = &[
                48, 86, 102, 116, 69, 120, 116, 101, 110, 115, 105, 111, 110, 56, 77, 105, 110,
                105, 109, 117, 109, 66, 97, 108, 97, 110, 99, 101,
            ];
            type Params = ();
            type Reply = U256;
        }
        pub struct UnusedValue(());
        impl UnusedValue {
            #[allow(dead_code)]
            pub fn encode_call() -> Vec<u8> {
                <UnusedValue as ActionIo>::encode_call(&())
            }
        }
        impl ActionIo for UnusedValue {
            const ROUTE: &'static [u8] = &[
                48, 86, 102, 116, 69, 120, 116, 101, 110, 115, 105, 111, 110, 44, 85, 110, 117,
                115, 101, 100, 86, 97, 108, 117, 101,
            ];
            type Params = ();
            type Reply = U256;
        }
    }
}
pub struct VftMetadata<R> {
    remoting: R,
}
impl<R> VftMetadata<R> {
    pub fn new(remoting: R) -> Self {
        Self { remoting }
    }
}
impl<R: Remoting + Clone> traits::VftMetadata for VftMetadata<R> {
    type Args = R::Args;
    /// Returns the number of decimals of the VFT.
    fn decimals(&self) -> impl Query<Output = u8, Args = R::Args> {
        RemotingAction::<_, vft_metadata::io::Decimals>::new(self.remoting.clone(), ())
    }
    /// Returns the name of the VFT.
    fn name(&self) -> impl Query<Output = String, Args = R::Args> {
        RemotingAction::<_, vft_metadata::io::Name>::new(self.remoting.clone(), ())
    }
    /// Returns the symbol of the VFT.
    fn symbol(&self) -> impl Query<Output = String, Args = R::Args> {
        RemotingAction::<_, vft_metadata::io::Symbol>::new(self.remoting.clone(), ())
    }
}

pub mod vft_metadata {
    use super::*;

    pub mod io {
        use super::*;
        use sails_rs::calls::ActionIo;
        pub struct Decimals(());
        impl Decimals {
            #[allow(dead_code)]
            pub fn encode_call() -> Vec<u8> {
                <Decimals as ActionIo>::encode_call(&())
            }
        }
        impl ActionIo for Decimals {
            const ROUTE: &'static [u8] = &[
                44, 86, 102, 116, 77, 101, 116, 97, 100, 97, 116, 97, 32, 68, 101, 99, 105, 109,
                97, 108, 115,
            ];
            type Params = ();
            type Reply = u8;
        }
        pub struct Name(());
        impl Name {
            #[allow(dead_code)]
            pub fn encode_call() -> Vec<u8> {
                <Name as ActionIo>::encode_call(&())
            }
        }
        impl ActionIo for Name {
            const ROUTE: &'static [u8] = &[
                44, 86, 102, 116, 77, 101, 116, 97, 100, 97, 116, 97, 16, 78, 97, 109, 101,
            ];
            type Params = ();
            type Reply = String;
        }
        pub struct Symbol(());
        impl Symbol {
            #[allow(dead_code)]
            pub fn encode_call() -> Vec<u8> {
                <Symbol as ActionIo>::encode_call(&())
            }
        }
        impl ActionIo for Symbol {
            const ROUTE: &'static [u8] = &[
                44, 86, 102, 116, 77, 101, 116, 97, 100, 97, 116, 97, 24, 83, 121, 109, 98, 111,
                108,
            ];
            type Params = ();
            type Reply = String;
        }
    }
}
pub struct VftNativeExchange<R> {
    remoting: R,
}
impl<R> VftNativeExchange<R> {
    pub fn new(remoting: R) -> Self {
        Self { remoting }
    }
}
impl<R: Remoting + Clone> traits::VftNativeExchange for VftNativeExchange<R> {
    type Args = R::Args;
    fn burn(&mut self, value: U256) -> impl Call<Output = (), Args = R::Args> {
        RemotingAction::<_, vft_native_exchange::io::Burn>::new(self.remoting.clone(), value)
    }
    fn burn_all(&mut self) -> impl Call<Output = (), Args = R::Args> {
        RemotingAction::<_, vft_native_exchange::io::BurnAll>::new(self.remoting.clone(), ())
    }
    fn mint(&mut self) -> impl Call<Output = (), Args = R::Args> {
        RemotingAction::<_, vft_native_exchange::io::Mint>::new(self.remoting.clone(), ())
    }
}

pub mod vft_native_exchange {
    use super::*;

    pub mod io {
        use super::*;
        use sails_rs::calls::ActionIo;
        pub struct Burn(());
        impl Burn {
            #[allow(dead_code)]
            pub fn encode_call(value: U256) -> Vec<u8> {
                <Burn as ActionIo>::encode_call(&value)
            }
        }
        impl ActionIo for Burn {
            const ROUTE: &'static [u8] = &[
                68, 86, 102, 116, 78, 97, 116, 105, 118, 101, 69, 120, 99, 104, 97, 110, 103, 101,
                16, 66, 117, 114, 110,
            ];
            type Params = U256;
            type Reply = ();
        }
        pub struct BurnAll(());
        impl BurnAll {
            #[allow(dead_code)]
            pub fn encode_call() -> Vec<u8> {
                <BurnAll as ActionIo>::encode_call(&())
            }
        }
        impl ActionIo for BurnAll {
            const ROUTE: &'static [u8] = &[
                68, 86, 102, 116, 78, 97, 116, 105, 118, 101, 69, 120, 99, 104, 97, 110, 103, 101,
                28, 66, 117, 114, 110, 65, 108, 108,
            ];
            type Params = ();
            type Reply = ();
        }
        pub struct Mint(());
        impl Mint {
            #[allow(dead_code)]
            pub fn encode_call() -> Vec<u8> {
                <Mint as ActionIo>::encode_call(&())
            }
        }
        impl ActionIo for Mint {
            const ROUTE: &'static [u8] = &[
                68, 86, 102, 116, 78, 97, 116, 105, 118, 101, 69, 120, 99, 104, 97, 110, 103, 101,
                16, 77, 105, 110, 116,
            ];
            type Params = ();
            type Reply = ();
        }
    }
}

pub mod traits {
    use super::*;
    #[allow(dead_code)]
    pub trait TestBinFactory {
        type Args;
        #[allow(clippy::new_ret_no_self)]
        #[allow(clippy::wrong_self_convention)]
        fn new(&self) -> impl Activation<Args = Self::Args>;
    }

    #[allow(clippy::type_complexity)]
    pub trait Test {
        type Args;
        fn set(
            &mut self,
            new_allowances: Vec<(ActorId, ActorId, U256, u32)>,
            new_balances: Vec<(ActorId, U256)>,
            minimum_balance: U256,
            expiry_period: u32,
        ) -> impl Call<Output = (), Args = Self::Args>;
    }

    #[allow(clippy::type_complexity)]
    pub trait Vft {
        type Args;
        fn approve(
            &mut self,
            spender: ActorId,
            value: U256,
        ) -> impl Call<Output = bool, Args = Self::Args>;
        fn transfer(
            &mut self,
            to: ActorId,
            value: U256,
        ) -> impl Call<Output = bool, Args = Self::Args>;
        fn transfer_from(
            &mut self,
            from: ActorId,
            to: ActorId,
            value: U256,
        ) -> impl Call<Output = bool, Args = Self::Args>;
        fn allowance(
            &self,
            owner: ActorId,
            spender: ActorId,
        ) -> impl Query<Output = U256, Args = Self::Args>;
        fn balance_of(&self, account: ActorId) -> impl Query<Output = U256, Args = Self::Args>;
        fn total_supply(&self) -> impl Query<Output = U256, Args = Self::Args>;
    }

    #[allow(clippy::type_complexity)]
    pub trait VftAdmin {
        type Args;
        fn append_allowances_shard(
            &mut self,
            capacity: u32,
        ) -> impl Call<Output = (), Args = Self::Args>;
        fn append_balances_shard(
            &mut self,
            capacity: u32,
        ) -> impl Call<Output = (), Args = Self::Args>;
        fn approve_from(
            &mut self,
            owner: ActorId,
            spender: ActorId,
            value: U256,
        ) -> impl Call<Output = bool, Args = Self::Args>;
        fn burn(&mut self, from: ActorId, value: U256)
        -> impl Call<Output = (), Args = Self::Args>;
        fn exit(&mut self, inheritor: ActorId) -> impl Call<Output = (), Args = Self::Args>;
        fn mint(&mut self, to: ActorId, value: U256) -> impl Call<Output = (), Args = Self::Args>;
        fn pause(&mut self) -> impl Call<Output = (), Args = Self::Args>;
        fn resume(&mut self) -> impl Call<Output = (), Args = Self::Args>;
        fn set_admin(&mut self, admin: ActorId) -> impl Call<Output = (), Args = Self::Args>;
        fn set_burner(&mut self, burner: ActorId) -> impl Call<Output = (), Args = Self::Args>;
        fn set_expiry_period(&mut self, period: u32) -> impl Call<Output = (), Args = Self::Args>;
        fn set_minimum_balance(&mut self, value: U256)
        -> impl Call<Output = (), Args = Self::Args>;
        fn set_minter(&mut self, minter: ActorId) -> impl Call<Output = (), Args = Self::Args>;
        fn set_pauser(&mut self, pauser: ActorId) -> impl Call<Output = (), Args = Self::Args>;
        fn admin(&self) -> impl Query<Output = ActorId, Args = Self::Args>;
        fn burner(&self) -> impl Query<Output = ActorId, Args = Self::Args>;
        fn is_paused(&self) -> impl Query<Output = bool, Args = Self::Args>;
        fn minter(&self) -> impl Query<Output = ActorId, Args = Self::Args>;
        fn pauser(&self) -> impl Query<Output = ActorId, Args = Self::Args>;
    }

    #[allow(clippy::type_complexity)]
    pub trait VftExtension {
        type Args;
        fn allocate_next_allowances_shard(&mut self)
        -> impl Call<Output = bool, Args = Self::Args>;
        fn allocate_next_balances_shard(&mut self) -> impl Call<Output = bool, Args = Self::Args>;
        fn remove_expired_allowance(
            &mut self,
            owner: ActorId,
            spender: ActorId,
        ) -> impl Call<Output = bool, Args = Self::Args>;
        fn transfer_all(&mut self, to: ActorId) -> impl Call<Output = bool, Args = Self::Args>;
        fn transfer_all_from(
            &mut self,
            from: ActorId,
            to: ActorId,
        ) -> impl Call<Output = bool, Args = Self::Args>;
        fn allowance_of(
            &self,
            owner: ActorId,
            spender: ActorId,
        ) -> impl Query<Output = Option<(U256, u32)>, Args = Self::Args>;
        fn allowances(
            &self,
            cursor: u32,
            len: u32,
        ) -> impl Query<Output = Vec<((ActorId, ActorId), (U256, u32))>, Args = Self::Args>;
        fn balance_of(
            &self,
            account: ActorId,
        ) -> impl Query<Output = Option<U256>, Args = Self::Args>;
        fn balances(
            &self,
            cursor: u32,
            len: u32,
        ) -> impl Query<Output = Vec<(ActorId, U256)>, Args = Self::Args>;
        fn expiry_period(&self) -> impl Query<Output = u32, Args = Self::Args>;
        fn minimum_balance(&self) -> impl Query<Output = U256, Args = Self::Args>;
        fn unused_value(&self) -> impl Query<Output = U256, Args = Self::Args>;
    }

    #[allow(clippy::type_complexity)]
    pub trait VftMetadata {
        type Args;
        fn decimals(&self) -> impl Query<Output = u8, Args = Self::Args>;
        fn name(&self) -> impl Query<Output = String, Args = Self::Args>;
        fn symbol(&self) -> impl Query<Output = String, Args = Self::Args>;
    }

    #[allow(clippy::type_complexity)]
    pub trait VftNativeExchange {
        type Args;
        fn burn(&mut self, value: U256) -> impl Call<Output = (), Args = Self::Args>;
        fn burn_all(&mut self) -> impl Call<Output = (), Args = Self::Args>;
        fn mint(&mut self) -> impl Call<Output = (), Args = Self::Args>;
    }
}
