// Code generated by sails-client-gen. DO NOT EDIT.
#[allow(unused_imports)]
use sails_rs::{client::*, collections::*, prelude::*};
pub struct AwesomeSailsTestClientProgram;
impl sails_rs::client::Program for AwesomeSailsTestClientProgram {}
pub trait AwesomeSailsTestClient {
    type Env: sails_rs::client::GearEnv;
    fn test(&self) -> sails_rs::client::Service<test::TestImpl, Self::Env>;
    fn access_control(
        &self,
    ) -> sails_rs::client::Service<access_control::AccessControlImpl, Self::Env>;
    fn vft(&self) -> sails_rs::client::Service<vft::VftImpl, Self::Env>;
    fn vft_admin(&self) -> sails_rs::client::Service<vft_admin::VftAdminImpl, Self::Env>;
    fn vft_extension(
        &self,
    ) -> sails_rs::client::Service<vft_extension::VftExtensionImpl, Self::Env>;
    fn vft_metadata(&self) -> sails_rs::client::Service<vft_metadata::VftMetadataImpl, Self::Env>;
    fn vft_native_exchange(
        &self,
    ) -> sails_rs::client::Service<vft_native_exchange::VftNativeExchangeImpl, Self::Env>;
    fn vft_native_exchange_admin(
        &self,
    ) -> sails_rs::client::Service<vft_native_exchange_admin::VftNativeExchangeAdminImpl, Self::Env>;
}
impl<E: sails_rs::client::GearEnv> AwesomeSailsTestClient
    for sails_rs::client::Actor<AwesomeSailsTestClientProgram, E>
{
    type Env = E;
    fn test(&self) -> sails_rs::client::Service<test::TestImpl, Self::Env> {
        self.service(stringify!(Test))
    }
    fn access_control(
        &self,
    ) -> sails_rs::client::Service<access_control::AccessControlImpl, Self::Env> {
        self.service(stringify!(AccessControl))
    }
    fn vft(&self) -> sails_rs::client::Service<vft::VftImpl, Self::Env> {
        self.service(stringify!(Vft))
    }
    fn vft_admin(&self) -> sails_rs::client::Service<vft_admin::VftAdminImpl, Self::Env> {
        self.service(stringify!(VftAdmin))
    }
    fn vft_extension(
        &self,
    ) -> sails_rs::client::Service<vft_extension::VftExtensionImpl, Self::Env> {
        self.service(stringify!(VftExtension))
    }
    fn vft_metadata(&self) -> sails_rs::client::Service<vft_metadata::VftMetadataImpl, Self::Env> {
        self.service(stringify!(VftMetadata))
    }
    fn vft_native_exchange(
        &self,
    ) -> sails_rs::client::Service<vft_native_exchange::VftNativeExchangeImpl, Self::Env> {
        self.service(stringify!(VftNativeExchange))
    }
    fn vft_native_exchange_admin(
        &self,
    ) -> sails_rs::client::Service<vft_native_exchange_admin::VftNativeExchangeAdminImpl, Self::Env>
    {
        self.service(stringify!(VftNativeExchangeAdmin))
    }
}
pub trait AwesomeSailsTestClientCtors {
    type Env: sails_rs::client::GearEnv;
    #[allow(clippy::new_ret_no_self)]
    #[allow(clippy::wrong_self_convention)]
    fn new(
        self,
    ) -> sails_rs::client::PendingCtor<AwesomeSailsTestClientProgram, io::New, Self::Env>;
}
impl<E: sails_rs::client::GearEnv> AwesomeSailsTestClientCtors
    for sails_rs::client::Deployment<AwesomeSailsTestClientProgram, E>
{
    type Env = E;
    fn new(
        self,
    ) -> sails_rs::client::PendingCtor<AwesomeSailsTestClientProgram, io::New, Self::Env> {
        self.pending_ctor(())
    }
}

pub mod io {
    use super::*;
    sails_rs::io_struct_impl!(New () -> ());
}

pub mod test {
    use super::*;
    pub trait Test {
        type Env: sails_rs::client::GearEnv;
        fn set(
            &mut self,
            new_allowances: Vec<(ActorId, ActorId, U256, u32)>,
            new_balances: Vec<(ActorId, U256)>,
            expiry_period: u32,
        ) -> sails_rs::client::PendingCall<io::Set, Self::Env>;
    }
    pub struct TestImpl;
    impl<E: sails_rs::client::GearEnv> Test for sails_rs::client::Service<TestImpl, E> {
        type Env = E;
        fn set(
            &mut self,
            new_allowances: Vec<(ActorId, ActorId, U256, u32)>,
            new_balances: Vec<(ActorId, U256)>,
            expiry_period: u32,
        ) -> sails_rs::client::PendingCall<io::Set, Self::Env> {
            self.pending_call((new_allowances, new_balances, expiry_period))
        }
    }

    pub mod io {
        use super::*;
        sails_rs::io_struct_impl!(Set (new_allowances: Vec<(ActorId,ActorId,U256,u32,)>, new_balances: Vec<(ActorId,U256,)>, expiry_period: u32) -> ());
    }
}

pub mod access_control {
    use super::*;
    pub trait AccessControl {
        type Env: sails_rs::client::GearEnv;
        /// Grants `role_id` to `target_account`.
        ///
        /// If `target_account` had not been already granted `role_id`, emits a `RoleGranted`
        /// event.
        ///
        /// # Requirements
        ///
        /// * The caller must have `role_id`'s admin role.
        fn grant_role(
            &mut self,
            role_id: [u8; 32],
            target_account: ActorId,
        ) -> sails_rs::client::PendingCall<io::GrantRole, Self::Env>;
        /// Grants `role_ids` to `target_account`.
        ///
        /// If `target_account` had not been already granted any of the `role_ids`,
        /// emits a `RoleGranted` event for each newly granted role.
        ///
        /// # Requirements
        ///
        /// * The caller must have the admin role for all specified `role_ids`.
        fn grant_roles_batch(
            &mut self,
            role_ids: Vec<[u8; 32]>,
            target_account: ActorId,
        ) -> sails_rs::client::PendingCall<io::GrantRolesBatch, Self::Env>;
        /// Revokes `role_id` from the calling account.
        ///
        /// Roles are often managed via `grant_role` and `revoke_role`: this function's
        /// purpose is to provide a mechanism for accounts to lose their privileges
        /// if they are compromised (such as when a trusted device is misplaced).
        ///
        /// If the calling account had been granted `role_id`, emits a `RoleRevoked`
        /// event.
        ///
        /// # Requirements
        ///
        /// * The caller must be `account_id`.
        fn renounce_role(
            &mut self,
            role_id: [u8; 32],
            account_id: ActorId,
        ) -> sails_rs::client::PendingCall<io::RenounceRole, Self::Env>;
        /// Revokes `role_id` from `target_account`.
        ///
        /// If `target_account` had been granted `role_id`, emits a `RoleRevoked` event.
        ///
        /// # Requirements
        ///
        /// * The caller must have `role_id`'s admin role.
        fn revoke_role(
            &mut self,
            role_id: [u8; 32],
            target_account: ActorId,
        ) -> sails_rs::client::PendingCall<io::RevokeRole, Self::Env>;
        /// Revokes `role_ids` from `target_account`.
        ///
        /// If `target_account` had been granted any of the `role_ids`,
        /// emits a `RoleRevoked` event for each newly revoked role.
        ///
        /// # Requirements
        ///
        /// * The caller must have the admin role for all specified `role_ids`.
        fn revoke_roles_batch(
            &mut self,
            role_ids: Vec<[u8; 32]>,
            target_account: ActorId,
        ) -> sails_rs::client::PendingCall<io::RevokeRolesBatch, Self::Env>;
        /// Sets `new_admin_role_id` as the admin role for `role_id`.
        ///
        /// Emits a `RoleAdminChanged` event.
        ///
        /// # Requirements
        ///
        /// * The caller must have `role_id`'s admin role.
        fn set_role_admin(
            &mut self,
            role_id: [u8; 32],
            new_admin_role_id: [u8; 32],
        ) -> sails_rs::client::PendingCall<io::SetRoleAdmin, Self::Env>;
        /// Returns the number of roles assigned to the specified member.
        ///
        /// # Arguments
        ///
        /// * `member_id` - The account identifier.
        fn get_member_role_count(
            &self,
            member_id: ActorId,
        ) -> sails_rs::client::PendingCall<io::GetMemberRoleCount, Self::Env>;
        /// Returns a list of roles assigned to the specified member with pagination.
        ///
        /// # Arguments
        ///
        /// * `member_id` - The account identifier.
        /// * `query` - Optional pagination configuration.
        fn get_member_roles(
            &self,
            member_id: ActorId,
            query: Option<Pagination>,
        ) -> sails_rs::client::PendingCall<io::GetMemberRoles, Self::Env>;
        /// Returns the admin role ID that controls `role_id`.
        ///
        /// # Arguments
        ///
        /// * `role_id` - The role identifier.
        ///
        /// # Returns
        ///
        /// The `RoleId` of the administrator.
        fn get_role_admin(
            &self,
            role_id: [u8; 32],
        ) -> sails_rs::client::PendingCall<io::GetRoleAdmin, Self::Env>;
        /// Returns the total number of roles in the system.
        fn get_role_count(&self) -> sails_rs::client::PendingCall<io::GetRoleCount, Self::Env>;
        /// Returns the number of members in the specified role.
        ///
        /// # Arguments
        ///
        /// * `role_id` - The role identifier.
        fn get_role_member_count(
            &self,
            role_id: [u8; 32],
        ) -> sails_rs::client::PendingCall<io::GetRoleMemberCount, Self::Env>;
        /// Returns a list of members in the specified role with pagination.
        ///
        /// # Arguments
        ///
        /// * `role_id` - The role identifier.
        /// * `query` - Optional pagination configuration.
        fn get_role_members(
            &self,
            role_id: [u8; 32],
            query: Option<Pagination>,
        ) -> sails_rs::client::PendingCall<io::GetRoleMembers, Self::Env>;
        /// Returns a list of role IDs with pagination.
        ///
        /// # Arguments
        ///
        /// * `query` - Optional pagination configuration.
        fn get_roles(
            &self,
            query: Option<Pagination>,
        ) -> sails_rs::client::PendingCall<io::GetRoles, Self::Env>;
        /// Checks if `account_id` has been granted `role_id`.
        ///
        /// # Arguments
        ///
        /// * `role_id` - The role identifier.
        /// * `account_id` - The account identifier.
        ///
        /// # Returns
        ///
        /// `true` if the account possesses the role.
        fn has_role(
            &self,
            role_id: [u8; 32],
            account_id: ActorId,
        ) -> sails_rs::client::PendingCall<io::HasRole, Self::Env>;
    }
    pub struct AccessControlImpl;
    impl<E: sails_rs::client::GearEnv> AccessControl
        for sails_rs::client::Service<AccessControlImpl, E>
    {
        type Env = E;
        fn grant_role(
            &mut self,
            role_id: [u8; 32],
            target_account: ActorId,
        ) -> sails_rs::client::PendingCall<io::GrantRole, Self::Env> {
            self.pending_call((role_id, target_account))
        }
        fn grant_roles_batch(
            &mut self,
            role_ids: Vec<[u8; 32]>,
            target_account: ActorId,
        ) -> sails_rs::client::PendingCall<io::GrantRolesBatch, Self::Env> {
            self.pending_call((role_ids, target_account))
        }
        fn renounce_role(
            &mut self,
            role_id: [u8; 32],
            account_id: ActorId,
        ) -> sails_rs::client::PendingCall<io::RenounceRole, Self::Env> {
            self.pending_call((role_id, account_id))
        }
        fn revoke_role(
            &mut self,
            role_id: [u8; 32],
            target_account: ActorId,
        ) -> sails_rs::client::PendingCall<io::RevokeRole, Self::Env> {
            self.pending_call((role_id, target_account))
        }
        fn revoke_roles_batch(
            &mut self,
            role_ids: Vec<[u8; 32]>,
            target_account: ActorId,
        ) -> sails_rs::client::PendingCall<io::RevokeRolesBatch, Self::Env> {
            self.pending_call((role_ids, target_account))
        }
        fn set_role_admin(
            &mut self,
            role_id: [u8; 32],
            new_admin_role_id: [u8; 32],
        ) -> sails_rs::client::PendingCall<io::SetRoleAdmin, Self::Env> {
            self.pending_call((role_id, new_admin_role_id))
        }
        fn get_member_role_count(
            &self,
            member_id: ActorId,
        ) -> sails_rs::client::PendingCall<io::GetMemberRoleCount, Self::Env> {
            self.pending_call((member_id,))
        }
        fn get_member_roles(
            &self,
            member_id: ActorId,
            query: Option<Pagination>,
        ) -> sails_rs::client::PendingCall<io::GetMemberRoles, Self::Env> {
            self.pending_call((member_id, query))
        }
        fn get_role_admin(
            &self,
            role_id: [u8; 32],
        ) -> sails_rs::client::PendingCall<io::GetRoleAdmin, Self::Env> {
            self.pending_call((role_id,))
        }
        fn get_role_count(&self) -> sails_rs::client::PendingCall<io::GetRoleCount, Self::Env> {
            self.pending_call(())
        }
        fn get_role_member_count(
            &self,
            role_id: [u8; 32],
        ) -> sails_rs::client::PendingCall<io::GetRoleMemberCount, Self::Env> {
            self.pending_call((role_id,))
        }
        fn get_role_members(
            &self,
            role_id: [u8; 32],
            query: Option<Pagination>,
        ) -> sails_rs::client::PendingCall<io::GetRoleMembers, Self::Env> {
            self.pending_call((role_id, query))
        }
        fn get_roles(
            &self,
            query: Option<Pagination>,
        ) -> sails_rs::client::PendingCall<io::GetRoles, Self::Env> {
            self.pending_call((query,))
        }
        fn has_role(
            &self,
            role_id: [u8; 32],
            account_id: ActorId,
        ) -> sails_rs::client::PendingCall<io::HasRole, Self::Env> {
            self.pending_call((role_id, account_id))
        }
    }

    pub mod io {
        use super::*;
        sails_rs::io_struct_impl!(GrantRole (role_id: [u8; 32], target_account: ActorId) -> ());
        sails_rs::io_struct_impl!(GrantRolesBatch (role_ids: Vec<[u8; 32]>, target_account: ActorId) -> ());
        sails_rs::io_struct_impl!(RenounceRole (role_id: [u8; 32], account_id: ActorId) -> ());
        sails_rs::io_struct_impl!(RevokeRole (role_id: [u8; 32], target_account: ActorId) -> ());
        sails_rs::io_struct_impl!(RevokeRolesBatch (role_ids: Vec<[u8; 32]>, target_account: ActorId) -> ());
        sails_rs::io_struct_impl!(SetRoleAdmin (role_id: [u8; 32], new_admin_role_id: [u8; 32]) -> ());
        sails_rs::io_struct_impl!(GetMemberRoleCount (member_id: ActorId) -> u32);
        sails_rs::io_struct_impl!(GetMemberRoles (member_id: ActorId, query: Option<super::Pagination>) -> Vec<[u8; 32]>);
        sails_rs::io_struct_impl!(GetRoleAdmin (role_id: [u8; 32]) -> [u8; 32]);
        sails_rs::io_struct_impl!(GetRoleCount () -> u32);
        sails_rs::io_struct_impl!(GetRoleMemberCount (role_id: [u8; 32]) -> u32);
        sails_rs::io_struct_impl!(GetRoleMembers (role_id: [u8; 32], query: Option<super::Pagination>) -> Vec<ActorId>);
        sails_rs::io_struct_impl!(GetRoles (query: Option<super::Pagination>) -> Vec<[u8; 32]>);
        sails_rs::io_struct_impl!(HasRole (role_id: [u8; 32], account_id: ActorId) -> bool);
    }

    #[cfg(not(target_arch = "wasm32"))]
    pub mod events {
        use super::*;
        #[derive(PartialEq, Debug, Encode, Decode)]
        #[codec(crate = sails_rs::scale_codec)]
        pub enum AccessControlEvents {
            /// Emitted when `target_account` is granted `role_id`.
            RoleGranted {
                role_id: [u8; 32],
                target_account: ActorId,
                sender: ActorId,
            },
            /// Emitted when `role_id` is revoked from `target_account`.
            RoleRevoked {
                role_id: [u8; 32],
                target_account: ActorId,
                sender: ActorId,
            },
            /// Emitted when `new_admin_role_id` is set as the admin role for `role_id`.
            RoleAdminChanged {
                role_id: [u8; 32],
                previous_admin_role_id: [u8; 32],
                new_admin_role_id: [u8; 32],
                sender: ActorId,
            },
        }
        impl sails_rs::client::Event for AccessControlEvents {
            const EVENT_NAMES: &'static [Route] =
                &["RoleGranted", "RoleRevoked", "RoleAdminChanged"];
        }
        impl sails_rs::client::ServiceWithEvents for AccessControlImpl {
            type Event = AccessControlEvents;
        }
    }
}

pub mod vft {
    use super::*;
    pub trait Vft {
        type Env: sails_rs::client::GearEnv;
        /// Approves `spender` to spend `value` amount of tokens on behalf of the caller.
        ///
        /// If `value` is `U256::MAX`, the allowance is treated as infinite.
        /// Emits an `Approval` event if the allowance value changes.
        ///
        /// # Arguments
        ///
        /// * `spender` - The account to be allowed to spend tokens.
        /// * `value` - The amount of tokens to approve.
        ///
        /// # Returns
        ///
        /// `true` if the approval value was changed, `false` otherwise.
        fn approve(
            &mut self,
            spender: ActorId,
            value: U256,
        ) -> sails_rs::client::PendingCall<io::Approve, Self::Env>;
        /// Transfers `value` amount of tokens from the caller to `to`.
        ///
        /// Emits a `Transfer` event.
        ///
        /// # Arguments
        ///
        /// * `to` - The recipient of the tokens.
        /// * `value` - The amount of tokens to transfer.
        ///
        /// # Returns
        ///
        /// `true` if the transfer was successful.
        fn transfer(
            &mut self,
            to: ActorId,
            value: U256,
        ) -> sails_rs::client::PendingCall<io::Transfer, Self::Env>;
        /// Transfers `value` amount of tokens from `from` to `to` using the allowance mechanism.
        ///
        /// The caller (spender) must have sufficient allowance from `from` (owner).
        /// Emits a `Transfer` event.
        ///
        /// # Arguments
        ///
        /// * `from` - The account to transfer tokens from.
        /// * `to` - The recipient of the tokens.
        /// * `value` - The amount of tokens to transfer.
        ///
        /// # Returns
        ///
        /// `true` if the transfer was successful.
        fn transfer_from(
            &mut self,
            from: ActorId,
            to: ActorId,
            value: U256,
        ) -> sails_rs::client::PendingCall<io::TransferFrom, Self::Env>;
        /// Returns the amount of tokens that `spender` is allowed to spend on behalf of `owner`.
        ///
        /// # Arguments
        ///
        /// * `owner` - The account that owns the tokens.
        /// * `spender` - The account allowed to spend the tokens.
        ///
        /// # Returns
        ///
        /// The remaining allowance as `U256`.
        fn allowance(
            &self,
            owner: ActorId,
            spender: ActorId,
        ) -> sails_rs::client::PendingCall<io::Allowance, Self::Env>;
        /// Returns the token balance of `account`.
        ///
        /// # Arguments
        ///
        /// * `account` - The account to query the balance of.
        ///
        /// # Returns
        ///
        /// The balance as `U256`.
        fn balance_of(
            &self,
            account: ActorId,
        ) -> sails_rs::client::PendingCall<io::BalanceOf, Self::Env>;
        /// Returns the total supply of tokens.
        ///
        /// # Returns
        ///
        /// The total supply as `U256`.
        fn total_supply(&self) -> sails_rs::client::PendingCall<io::TotalSupply, Self::Env>;
    }
    pub struct VftImpl;
    impl<E: sails_rs::client::GearEnv> Vft for sails_rs::client::Service<VftImpl, E> {
        type Env = E;
        fn approve(
            &mut self,
            spender: ActorId,
            value: U256,
        ) -> sails_rs::client::PendingCall<io::Approve, Self::Env> {
            self.pending_call((spender, value))
        }
        fn transfer(
            &mut self,
            to: ActorId,
            value: U256,
        ) -> sails_rs::client::PendingCall<io::Transfer, Self::Env> {
            self.pending_call((to, value))
        }
        fn transfer_from(
            &mut self,
            from: ActorId,
            to: ActorId,
            value: U256,
        ) -> sails_rs::client::PendingCall<io::TransferFrom, Self::Env> {
            self.pending_call((from, to, value))
        }
        fn allowance(
            &self,
            owner: ActorId,
            spender: ActorId,
        ) -> sails_rs::client::PendingCall<io::Allowance, Self::Env> {
            self.pending_call((owner, spender))
        }
        fn balance_of(
            &self,
            account: ActorId,
        ) -> sails_rs::client::PendingCall<io::BalanceOf, Self::Env> {
            self.pending_call((account,))
        }
        fn total_supply(&self) -> sails_rs::client::PendingCall<io::TotalSupply, Self::Env> {
            self.pending_call(())
        }
    }

    pub mod io {
        use super::*;
        sails_rs::io_struct_impl!(Approve (spender: ActorId, value: U256) -> bool);
        sails_rs::io_struct_impl!(Transfer (to: ActorId, value: U256) -> bool);
        sails_rs::io_struct_impl!(TransferFrom (from: ActorId, to: ActorId, value: U256) -> bool);
        sails_rs::io_struct_impl!(Allowance (owner: ActorId, spender: ActorId) -> U256);
        sails_rs::io_struct_impl!(BalanceOf (account: ActorId) -> U256);
        sails_rs::io_struct_impl!(TotalSupply () -> U256);
    }

    #[cfg(not(target_arch = "wasm32"))]
    pub mod events {
        use super::*;
        #[derive(PartialEq, Debug, Encode, Decode)]
        #[codec(crate = sails_rs::scale_codec)]
        pub enum VftEvents {
            /// Emitted when an approval is granted or updated.
            Approval {
                owner: ActorId,
                spender: ActorId,
                value: U256,
            },
            /// Emitted when tokens are transferred.
            Transfer {
                from: ActorId,
                to: ActorId,
                value: U256,
            },
        }
        impl sails_rs::client::Event for VftEvents {
            const EVENT_NAMES: &'static [Route] = &["Approval", "Transfer"];
        }
        impl sails_rs::client::ServiceWithEvents for VftImpl {
            type Event = VftEvents;
        }
    }
}

pub mod vft_admin {
    use super::*;
    pub trait VftAdmin {
        type Env: sails_rs::client::GearEnv;
        /// Appends a new shard to the allowances storage map.
        ///
        /// # Requirements
        /// * Caller must have `DEFAULT_ADMIN_ROLE`.
        ///
        /// # Arguments
        /// * `capacity` - The capacity of the new shard.
        fn append_allowances_shard(
            &mut self,
            capacity: u32,
        ) -> sails_rs::client::PendingCall<io::AppendAllowancesShard, Self::Env>;
        /// Appends a new shard to the balances storage map.
        ///
        /// # Requirements
        /// * Caller must have `DEFAULT_ADMIN_ROLE`.
        ///
        /// # Arguments
        /// * `capacity` - The capacity of the new shard.
        fn append_balances_shard(
            &mut self,
            capacity: u32,
        ) -> sails_rs::client::PendingCall<io::AppendBalancesShard, Self::Env>;
        /// Approves `spender` to spend `value` from `owner`'s account.
        ///
        /// This is an admin function allowing the admin to set approvals arbitrarily.
        ///
        /// # Requirements
        /// * Caller must have `DEFAULT_ADMIN_ROLE`.
        ///
        /// # Arguments
        /// * `owner` - The account owning the tokens.
        /// * `spender` - The account to be approved.
        /// * `value` - The amount to approve.
        fn approve_from(
            &mut self,
            owner: ActorId,
            spender: ActorId,
            value: U256,
        ) -> sails_rs::client::PendingCall<io::ApproveFrom, Self::Env>;
        /// Burns `value` tokens from `from` account.
        ///
        /// # Requirements
        /// * Caller must have `BURNER_ROLE`.
        ///
        /// # Arguments
        /// * `from` - The account to burn tokens from.
        /// * `value` - The amount to burn.
        fn burn(
            &mut self,
            from: ActorId,
            value: U256,
        ) -> sails_rs::client::PendingCall<io::Burn, Self::Env>;
        /// Terminates the program and sends value to `inheritor`.
        ///
        /// # Requirements
        /// * Caller must have `DEFAULT_ADMIN_ROLE`.
        /// * Program must be paused.
        fn exit(
            &mut self,
            inheritor: ActorId,
        ) -> sails_rs::client::PendingCall<io::Exit, Self::Env>;
        /// Mints `value` tokens to `to` account.
        ///
        /// # Requirements
        /// * Caller must have `MINTER_ROLE`.
        ///
        /// # Arguments
        /// * `to` - The recipient of the minted tokens.
        /// * `value` - The amount to mint.
        fn mint(
            &mut self,
            to: ActorId,
            value: U256,
        ) -> sails_rs::client::PendingCall<io::Mint, Self::Env>;
        /// Pauses the contract.
        ///
        /// # Requirements
        /// * Caller must have `PAUSER_ROLE`.
        fn pause(&mut self) -> sails_rs::client::PendingCall<io::Pause, Self::Env>;
        /// Resumes the contract.
        ///
        /// # Requirements
        /// * Caller must have `PAUSER_ROLE`.
        fn resume(&mut self) -> sails_rs::client::PendingCall<io::Resume, Self::Env>;
        /// Sets the expiry period for allowances.
        ///
        /// # Requirements
        /// * Caller must have `DEFAULT_ADMIN_ROLE`.
        ///
        /// # Arguments
        /// * `period` - The new expiry period in blocks.
        fn set_expiry_period(
            &mut self,
            period: u32,
        ) -> sails_rs::client::PendingCall<io::SetExpiryPeriod, Self::Env>;
        /// Returns `true` if the contract is paused.
        fn is_paused(&self) -> sails_rs::client::PendingCall<io::IsPaused, Self::Env>;
    }
    pub struct VftAdminImpl;
    impl<E: sails_rs::client::GearEnv> VftAdmin for sails_rs::client::Service<VftAdminImpl, E> {
        type Env = E;
        fn append_allowances_shard(
            &mut self,
            capacity: u32,
        ) -> sails_rs::client::PendingCall<io::AppendAllowancesShard, Self::Env> {
            self.pending_call((capacity,))
        }
        fn append_balances_shard(
            &mut self,
            capacity: u32,
        ) -> sails_rs::client::PendingCall<io::AppendBalancesShard, Self::Env> {
            self.pending_call((capacity,))
        }
        fn approve_from(
            &mut self,
            owner: ActorId,
            spender: ActorId,
            value: U256,
        ) -> sails_rs::client::PendingCall<io::ApproveFrom, Self::Env> {
            self.pending_call((owner, spender, value))
        }
        fn burn(
            &mut self,
            from: ActorId,
            value: U256,
        ) -> sails_rs::client::PendingCall<io::Burn, Self::Env> {
            self.pending_call((from, value))
        }
        fn exit(
            &mut self,
            inheritor: ActorId,
        ) -> sails_rs::client::PendingCall<io::Exit, Self::Env> {
            self.pending_call((inheritor,))
        }
        fn mint(
            &mut self,
            to: ActorId,
            value: U256,
        ) -> sails_rs::client::PendingCall<io::Mint, Self::Env> {
            self.pending_call((to, value))
        }
        fn pause(&mut self) -> sails_rs::client::PendingCall<io::Pause, Self::Env> {
            self.pending_call(())
        }
        fn resume(&mut self) -> sails_rs::client::PendingCall<io::Resume, Self::Env> {
            self.pending_call(())
        }
        fn set_expiry_period(
            &mut self,
            period: u32,
        ) -> sails_rs::client::PendingCall<io::SetExpiryPeriod, Self::Env> {
            self.pending_call((period,))
        }
        fn is_paused(&self) -> sails_rs::client::PendingCall<io::IsPaused, Self::Env> {
            self.pending_call(())
        }
    }

    pub mod io {
        use super::*;
        sails_rs::io_struct_impl!(AppendAllowancesShard (capacity: u32) -> ());
        sails_rs::io_struct_impl!(AppendBalancesShard (capacity: u32) -> ());
        sails_rs::io_struct_impl!(ApproveFrom (owner: ActorId, spender: ActorId, value: U256) -> bool);
        sails_rs::io_struct_impl!(Burn (from: ActorId, value: U256) -> ());
        sails_rs::io_struct_impl!(Exit (inheritor: ActorId) -> ());
        sails_rs::io_struct_impl!(Mint (to: ActorId, value: U256) -> ());
        sails_rs::io_struct_impl!(Pause () -> ());
        sails_rs::io_struct_impl!(Resume () -> ());
        sails_rs::io_struct_impl!(SetExpiryPeriod (period: u32) -> ());
        sails_rs::io_struct_impl!(IsPaused () -> bool);
    }

    #[cfg(not(target_arch = "wasm32"))]
    pub mod events {
        use super::*;
        #[derive(PartialEq, Debug, Encode, Decode)]
        #[codec(crate = sails_rs::scale_codec)]
        pub enum VftAdminEvents {
            BurnerTookPlace,
            MinterTookPlace,
            /// Emitted when the allowance expiry period is changed.
            ExpiryPeriodChanged(u32),
            /// Emitted when the program exits.
            Exited(ActorId),
            Paused,
            Resumed,
        }
        impl sails_rs::client::Event for VftAdminEvents {
            const EVENT_NAMES: &'static [Route] = &[
                "BurnerTookPlace",
                "MinterTookPlace",
                "ExpiryPeriodChanged",
                "Exited",
                "Paused",
                "Resumed",
            ];
        }
        impl sails_rs::client::ServiceWithEvents for VftAdminImpl {
            type Event = VftAdminEvents;
        }
    }
}

pub mod vft_extension {
    use super::*;
    pub trait VftExtension {
        type Env: sails_rs::client::GearEnv;
        /// Allocates the next shard for allowances storage.
        ///
        /// Useful when the current shard is full.
        ///
        /// # Returns
        ///
        /// `true` if a new shard was allocated, `false` otherwise.
        fn allocate_next_allowances_shard(
            &mut self,
        ) -> sails_rs::client::PendingCall<io::AllocateNextAllowancesShard, Self::Env>;
        /// Allocates the next shard for balances storage.
        ///
        /// Useful when the current shard is full.
        ///
        /// # Returns
        ///
        /// `true` if a new shard was allocated, `false` otherwise.
        fn allocate_next_balances_shard(
            &mut self,
        ) -> sails_rs::client::PendingCall<io::AllocateNextBalancesShard, Self::Env>;
        /// Removes an expired allowance.
        ///
        /// If the allowance from `owner` to `spender` has expired, it is removed to free up storage.
        ///
        /// # Arguments
        ///
        /// * `owner` - The account that granted the allowance.
        /// * `spender` - The account that was granted the allowance.
        ///
        /// # Returns
        ///
        /// `true` if the allowance was removed, `false` otherwise (e.g., if it didn't exist).
        fn remove_expired_allowance(
            &mut self,
            owner: ActorId,
            spender: ActorId,
        ) -> sails_rs::client::PendingCall<io::RemoveExpiredAllowance, Self::Env>;
        /// Transfers the entire balance from the caller to `to`.
        ///
        /// # Arguments
        ///
        /// * `to` - The recipient of the tokens.
        ///
        /// # Returns
        ///
        /// `true` if any tokens were transferred.
        fn transfer_all(
            &mut self,
            to: ActorId,
        ) -> sails_rs::client::PendingCall<io::TransferAll, Self::Env>;
        /// Transfers the entire balance from `from` to `to` using the allowance mechanism.
        ///
        /// The caller must have sufficient allowance.
        ///
        /// # Arguments
        ///
        /// * `from` - The account to transfer tokens from.
        /// * `to` - The recipient of the tokens.
        ///
        /// # Returns
        ///
        /// `true` if any tokens were transferred.
        fn transfer_all_from(
            &mut self,
            from: ActorId,
            to: ActorId,
        ) -> sails_rs::client::PendingCall<io::TransferAllFrom, Self::Env>;
        /// Returns the allowance detail (amount and expiration block) for a given owner and spender.
        ///
        /// # Arguments
        ///
        /// * `owner` - The account owning the tokens.
        /// * `spender` - The account allowed to spend the tokens.
        ///
        /// # Returns
        ///
        /// An `Option` containing a tuple `(U256, u32)` representing the amount and expiration block height.
        fn allowance_of(
            &self,
            owner: ActorId,
            spender: ActorId,
        ) -> sails_rs::client::PendingCall<io::AllowanceOf, Self::Env>;
        /// Returns a list of all allowances with pagination.
        ///
        /// # Arguments
        ///
        /// * `cursor` - The index to start from.
        /// * `len` - The number of items to return.
        ///
        /// # Returns
        ///
        /// A vector of allowance details.
        fn allowances(
            &self,
            cursor: u32,
            len: u32,
        ) -> sails_rs::client::PendingCall<io::Allowances, Self::Env>;
        /// Returns the balance of an account, if it exists in storage.
        ///
        /// Unlike `vft::balance_of` which returns 0 for non-existent accounts, this returns `None`.
        ///
        /// # Arguments
        ///
        /// * `account` - The account to query.
        ///
        /// # Returns
        ///
        /// An `Option<U256>` containing the balance.
        fn balance_of(
            &self,
            account: ActorId,
        ) -> sails_rs::client::PendingCall<io::BalanceOf, Self::Env>;
        /// Returns a list of all balances with pagination.
        ///
        /// # Arguments
        ///
        /// * `cursor` - The index to start from.
        /// * `len` - The number of items to return.
        ///
        /// # Returns
        ///
        /// A vector of `(ActorId, U256)` pairs.
        fn balances(
            &self,
            cursor: u32,
            len: u32,
        ) -> sails_rs::client::PendingCall<io::Balances, Self::Env>;
        /// Returns the configured allowance expiry period.
        fn expiry_period(&self) -> sails_rs::client::PendingCall<io::ExpiryPeriod, Self::Env>;
        /// Returns the amount of value (tokens) that are currently "unused" or reserved.
        fn unused_value(&self) -> sails_rs::client::PendingCall<io::UnusedValue, Self::Env>;
    }
    pub struct VftExtensionImpl;
    impl<E: sails_rs::client::GearEnv> VftExtension for sails_rs::client::Service<VftExtensionImpl, E> {
        type Env = E;
        fn allocate_next_allowances_shard(
            &mut self,
        ) -> sails_rs::client::PendingCall<io::AllocateNextAllowancesShard, Self::Env> {
            self.pending_call(())
        }
        fn allocate_next_balances_shard(
            &mut self,
        ) -> sails_rs::client::PendingCall<io::AllocateNextBalancesShard, Self::Env> {
            self.pending_call(())
        }
        fn remove_expired_allowance(
            &mut self,
            owner: ActorId,
            spender: ActorId,
        ) -> sails_rs::client::PendingCall<io::RemoveExpiredAllowance, Self::Env> {
            self.pending_call((owner, spender))
        }
        fn transfer_all(
            &mut self,
            to: ActorId,
        ) -> sails_rs::client::PendingCall<io::TransferAll, Self::Env> {
            self.pending_call((to,))
        }
        fn transfer_all_from(
            &mut self,
            from: ActorId,
            to: ActorId,
        ) -> sails_rs::client::PendingCall<io::TransferAllFrom, Self::Env> {
            self.pending_call((from, to))
        }
        fn allowance_of(
            &self,
            owner: ActorId,
            spender: ActorId,
        ) -> sails_rs::client::PendingCall<io::AllowanceOf, Self::Env> {
            self.pending_call((owner, spender))
        }
        fn allowances(
            &self,
            cursor: u32,
            len: u32,
        ) -> sails_rs::client::PendingCall<io::Allowances, Self::Env> {
            self.pending_call((cursor, len))
        }
        fn balance_of(
            &self,
            account: ActorId,
        ) -> sails_rs::client::PendingCall<io::BalanceOf, Self::Env> {
            self.pending_call((account,))
        }
        fn balances(
            &self,
            cursor: u32,
            len: u32,
        ) -> sails_rs::client::PendingCall<io::Balances, Self::Env> {
            self.pending_call((cursor, len))
        }
        fn expiry_period(&self) -> sails_rs::client::PendingCall<io::ExpiryPeriod, Self::Env> {
            self.pending_call(())
        }
        fn unused_value(&self) -> sails_rs::client::PendingCall<io::UnusedValue, Self::Env> {
            self.pending_call(())
        }
    }

    pub mod io {
        use super::*;
        sails_rs::io_struct_impl!(AllocateNextAllowancesShard () -> bool);
        sails_rs::io_struct_impl!(AllocateNextBalancesShard () -> bool);
        sails_rs::io_struct_impl!(RemoveExpiredAllowance (owner: ActorId, spender: ActorId) -> bool);
        sails_rs::io_struct_impl!(TransferAll (to: ActorId) -> bool);
        sails_rs::io_struct_impl!(TransferAllFrom (from: ActorId, to: ActorId) -> bool);
        sails_rs::io_struct_impl!(AllowanceOf (owner: ActorId, spender: ActorId) -> Option<(U256,u32,)>);
        sails_rs::io_struct_impl!(Allowances (cursor: u32, len: u32) -> Vec<((ActorId,ActorId,),(U256,u32,),)>);
        sails_rs::io_struct_impl!(BalanceOf (account: ActorId) -> Option<U256>);
        sails_rs::io_struct_impl!(Balances (cursor: u32, len: u32) -> Vec<(ActorId,U256,)>);
        sails_rs::io_struct_impl!(ExpiryPeriod () -> u32);
        sails_rs::io_struct_impl!(UnusedValue () -> U256);
    }
}

pub mod vft_metadata {
    use super::*;
    pub trait VftMetadata {
        type Env: sails_rs::client::GearEnv;
        /// Returns the number of decimals used by the VFT.
        ///
        /// # Returns
        ///
        /// The decimals as a `u8`.
        fn decimals(&self) -> sails_rs::client::PendingCall<io::Decimals, Self::Env>;
        /// Returns the name of the VFT.
        ///
        /// # Returns
        ///
        /// The name as a `String`.
        fn name(&self) -> sails_rs::client::PendingCall<io::Name, Self::Env>;
        /// Returns the symbol of the VFT.
        ///
        /// # Returns
        ///
        /// The symbol as a `String`.
        fn symbol(&self) -> sails_rs::client::PendingCall<io::Symbol, Self::Env>;
    }
    pub struct VftMetadataImpl;
    impl<E: sails_rs::client::GearEnv> VftMetadata for sails_rs::client::Service<VftMetadataImpl, E> {
        type Env = E;
        fn decimals(&self) -> sails_rs::client::PendingCall<io::Decimals, Self::Env> {
            self.pending_call(())
        }
        fn name(&self) -> sails_rs::client::PendingCall<io::Name, Self::Env> {
            self.pending_call(())
        }
        fn symbol(&self) -> sails_rs::client::PendingCall<io::Symbol, Self::Env> {
            self.pending_call(())
        }
    }

    pub mod io {
        use super::*;
        sails_rs::io_struct_impl!(Decimals () -> u8);
        sails_rs::io_struct_impl!(Name () -> String);
        sails_rs::io_struct_impl!(Symbol () -> String);
    }
}

pub mod vft_native_exchange {
    use super::*;
    pub trait VftNativeExchange {
        type Env: sails_rs::client::GearEnv;
        /// Burns `value` amount of VFT tokens and returns the equivalent amount of native value to the caller.
        ///
        /// # Arguments
        ///
        /// * `value` - The amount of VFT tokens to burn.
        ///
        /// # Returns
        ///
        /// A `CommandReply` containing the unit value `()` and transferring the native value.
        fn burn(&mut self, value: U256) -> sails_rs::client::PendingCall<io::Burn, Self::Env>;
        /// Burns all VFT tokens owned by the caller and returns the equivalent amount of native value.
        ///
        /// # Returns
        ///
        /// A `CommandReply` containing the unit value `()` and transferring the native value.
        fn burn_all(&mut self) -> sails_rs::client::PendingCall<io::BurnAll, Self::Env>;
        /// Mints VFT tokens to the caller equal to the amount of native value attached to the message.
        ///
        /// # Returns
        ///
        /// `Ok(())` on success.
        fn mint(&mut self) -> sails_rs::client::PendingCall<io::Mint, Self::Env>;
    }
    pub struct VftNativeExchangeImpl;
    impl<E: sails_rs::client::GearEnv> VftNativeExchange
        for sails_rs::client::Service<VftNativeExchangeImpl, E>
    {
        type Env = E;
        fn burn(&mut self, value: U256) -> sails_rs::client::PendingCall<io::Burn, Self::Env> {
            self.pending_call((value,))
        }
        fn burn_all(&mut self) -> sails_rs::client::PendingCall<io::BurnAll, Self::Env> {
            self.pending_call(())
        }
        fn mint(&mut self) -> sails_rs::client::PendingCall<io::Mint, Self::Env> {
            self.pending_call(())
        }
    }

    pub mod io {
        use super::*;
        sails_rs::io_struct_impl!(Burn (value: U256) -> ());
        sails_rs::io_struct_impl!(BurnAll () -> ());
        sails_rs::io_struct_impl!(Mint () -> ());
    }
}

pub mod vft_native_exchange_admin {
    use super::*;
    pub trait VftNativeExchangeAdmin {
        type Env: sails_rs::client::GearEnv;
        /// Burns `value` amount of VFT tokens from `from` account and sends the equivalent
        /// native value to `from`.
        ///
        /// This allows an admin (with burner role) to force an exchange/refund.
        ///
        /// # Arguments
        ///
        /// * `from` - The account to burn tokens from.
        /// * `value` - The amount of tokens to burn.
        ///
        /// # Returns
        ///
        /// `Ok(())` on success.
        fn burn_from(
            &mut self,
            from: ActorId,
            value: U256,
        ) -> sails_rs::client::PendingCall<io::BurnFrom, Self::Env>;
    }
    pub struct VftNativeExchangeAdminImpl;
    impl<E: sails_rs::client::GearEnv> VftNativeExchangeAdmin
        for sails_rs::client::Service<VftNativeExchangeAdminImpl, E>
    {
        type Env = E;
        fn burn_from(
            &mut self,
            from: ActorId,
            value: U256,
        ) -> sails_rs::client::PendingCall<io::BurnFrom, Self::Env> {
            self.pending_call((from, value))
        }
    }

    pub mod io {
        use super::*;
        sails_rs::io_struct_impl!(BurnFrom (from: ActorId, value: U256) -> ());
    }

    #[cfg(not(target_arch = "wasm32"))]
    pub mod events {
        use super::*;
        #[derive(PartialEq, Debug, Encode, Decode)]
        #[codec(crate = sails_rs::scale_codec)]
        pub enum VftNativeExchangeAdminEvents {
            /// Emitted when re-minting tokens after a failed transfer fails.
            FailedMint { to: ActorId, value: U256 },
        }
        impl sails_rs::client::Event for VftNativeExchangeAdminEvents {
            const EVENT_NAMES: &'static [Route] = &["FailedMint"];
        }
        impl sails_rs::client::ServiceWithEvents for VftNativeExchangeAdminImpl {
            type Event = VftNativeExchangeAdminEvents;
        }
    }
}
/// Pagination parameters for listing roles or members.
#[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
#[codec(crate = sails_rs::scale_codec)]
#[scale_info(crate = sails_rs::scale_info)]
pub struct Pagination {
    /// The number of items to skip.
    pub offset: u32,
    /// The maximum number of items to return.
    pub limit: u32,
}
