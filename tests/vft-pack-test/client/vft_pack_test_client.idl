constructor {
  New : ();
};

service Test {
  Set : (new_allowances: vec struct { actor_id, actor_id, u256, u32 }, new_balances: vec struct { actor_id, u256 }, expiry_period: u32) -> null;
};

service AccessControl {
  /// Grants `role_id` to `target_account`.
  /// 
  /// If `target_account` had not been already granted `role_id`, emits a `RoleGranted`
  /// event.
  /// 
  /// Requirements:
  /// 
  /// - the caller must have `role_id`'s admin role.
  GrantRole : (role_id: [u8, 32], target_account: actor_id) -> null;
  /// Grants `role_ids` to `target_accounts`.
  /// 
  /// If any of the `target_accounts` had not been already granted any of the `role_ids`,
  /// emits a `RolesGrantedBatch` event.
  /// 
  /// Requirements:
  /// 
  /// - the caller must have the admin role for all specified `role_ids`.
  GrantRolesBatch : (role_ids: vec [u8, 32], target_accounts: vec actor_id) -> null;
  /// Revokes `role_id` from the calling account.
  /// 
  /// Roles are often managed via `grant_role` and `revoke_role`: this function's
  /// purpose is to provide a mechanism for accounts to lose their privileges
  /// if they are compromised (such as when a trusted device is misplaced).
  /// 
  /// If the calling account had been granted `role_id`, emits a `RoleRevoked`
  /// event.
  /// 
  /// Requirements:
  /// 
  /// - the caller must be `account_id`.
  RenounceRole : (role_id: [u8, 32], account_id: actor_id) -> null;
  /// Revokes `role_id` from `target_account`.
  /// 
  /// If `target_account` had been granted `role_id`, emits a `RoleRevoked` event.
  /// 
  /// Requirements:
  /// 
  /// - the caller must have `role_id`'s admin role.
  RevokeRole : (role_id: [u8, 32], target_account: actor_id) -> null;
  /// Revokes `role_ids` from `target_accounts`.
  /// 
  /// If any of the `target_accounts` had been granted any of the `role_ids`,
  /// emits a `RolesRevokedBatch` event.
  /// 
  /// Requirements:
  /// 
  /// - the caller must have the admin role for all specified `role_ids`.
  RevokeRolesBatch : (role_ids: vec [u8, 32], target_accounts: vec actor_id) -> null;
  /// Sets `new_admin_role_id` as the admin role for `role_id`.
  /// 
  /// Emits a `RoleAdminChanged` event.
  /// 
  /// Requirements:
  /// 
  /// - the caller must have `role_id`'s admin role.
  SetRoleAdmin : (role_id: [u8, 32], new_admin_role_id: [u8, 32]) -> null;
  /// Returns the admin role ID that controls `role_id`.
  query GetRoleAdmin : (role_id: [u8, 32]) -> [u8, 32];
  /// Returns the number of roles in the system.
  query GetRoleCount : () -> u32;
  /// Returns the role ID at the specified index.
  query GetRoleId : (index: u32) -> opt [u8, 32];
  /// Returns the member at the specified index in the specified role.
  query GetRoleMember : (role_id: [u8, 32], index: u32) -> opt actor_id;
  /// Returns the number of members in the specified role.
  query GetRoleMemberCount : (role_id: [u8, 32]) -> u32;
  /// Returns `true` if `account_id` has been granted `role_id`.
  query HasRole : (role_id: [u8, 32], account_id: actor_id) -> bool;

  events {
    RoleGranted: struct {
      role_id: [u8, 32],
      target_account: actor_id,
      sender: actor_id,
    };
    RoleRevoked: struct {
      role_id: [u8, 32],
      target_account: actor_id,
      sender: actor_id,
    };
    RolesGrantedBatch: struct {
      role_ids: vec [u8, 32],
      target_accounts: vec actor_id,
      sender: actor_id,
    };
    RolesRevokedBatch: struct {
      role_ids: vec [u8, 32],
      target_accounts: vec actor_id,
      sender: actor_id,
    };
    RoleAdminChanged: struct {
      role_id: [u8, 32],
      previous_admin_role_id: [u8, 32],
      new_admin_role_id: [u8, 32],
      sender: actor_id,
    };
  }
};

service Vft {
  Approve : (spender: actor_id, value: u256) -> bool;
  Transfer : (to: actor_id, value: u256) -> bool;
  TransferFrom : (from: actor_id, to: actor_id, value: u256) -> bool;
  query Allowance : (owner: actor_id, spender: actor_id) -> u256;
  query BalanceOf : (account: actor_id) -> u256;
  query TotalSupply : () -> u256;

  events {
    Approval: struct {
      owner: actor_id,
      spender: actor_id,
      value: u256,
    };
    Transfer: struct {
      from: actor_id,
      to: actor_id,
      value: u256,
    };
  }
};

service VftAdmin {
  AppendAllowancesShard : (capacity: u32) -> null;
  AppendBalancesShard : (capacity: u32) -> null;
  ApproveFrom : (owner: actor_id, spender: actor_id, value: u256) -> bool;
  Burn : (from: actor_id, value: u256) -> null;
  Exit : (inheritor: actor_id) -> null;
  Mint : (to: actor_id, value: u256) -> null;
  Pause : () -> null;
  Resume : () -> null;
  SetExpiryPeriod : (period: u32) -> null;
  query IsPaused : () -> bool;

  events {
    BurnerTookPlace;
    MinterTookPlace;
    ExpiryPeriodChanged: u32;
    Exited: actor_id;
    Paused;
    Resumed;
  }
};

service VftExtension {
  AllocateNextAllowancesShard : () -> bool;
  AllocateNextBalancesShard : () -> bool;
  RemoveExpiredAllowance : (owner: actor_id, spender: actor_id) -> bool;
  TransferAll : (to: actor_id) -> bool;
  TransferAllFrom : (from: actor_id, to: actor_id) -> bool;
  query AllowanceOf : (owner: actor_id, spender: actor_id) -> opt struct { u256, u32 };
  query Allowances : (cursor: u32, len: u32) -> vec struct { struct { actor_id, actor_id }, struct { u256, u32 } };
  query BalanceOf : (account: actor_id) -> opt u256;
  query Balances : (cursor: u32, len: u32) -> vec struct { actor_id, u256 };
  query ExpiryPeriod : () -> u32;
  query UnusedValue : () -> u256;
};

service VftMetadata {
  /// Returns the number of decimals of the VFT.
  query Decimals : () -> u8;
  /// Returns the name of the VFT.
  query Name : () -> str;
  /// Returns the symbol of the VFT.
  query Symbol : () -> str;
};

service VftNativeExchange {
  Burn : (value: u256) -> null;
  BurnAll : () -> null;
  Mint : () -> null;
};

service VftNativeExchangeAdmin {
  BurnFrom : (from: actor_id, value: u256) -> null;

  events {
    FailedMint: struct {
      to: actor_id,
      value: u256,
    };
  }
};

