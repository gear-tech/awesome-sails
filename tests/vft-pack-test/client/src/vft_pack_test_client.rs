// Code generated by sails-client-gen. DO NOT EDIT.
#[allow(unused_imports)]
use sails_rs::{client::*, collections::*, prelude::*};
pub struct VftPackTestClientProgram;

impl sails_rs::client::Program for VftPackTestClientProgram {}

pub trait VftPackTestClient {
    type Env: sails_rs::client::GearEnv;
    fn test(&self) -> sails_rs::client::Service<test::TestImpl, Self::Env>;
    fn vft(&self) -> sails_rs::client::Service<vft::VftImpl, Self::Env>;
    fn vft_admin(&self) -> sails_rs::client::Service<vft_admin::VftAdminImpl, Self::Env>;
    fn vft_extension(
        &self,
    ) -> sails_rs::client::Service<vft_extension::VftExtensionImpl, Self::Env>;
    fn vft_metadata(&self) -> sails_rs::client::Service<vft_metadata::VftMetadataImpl, Self::Env>;
    fn vft_native_exchange(
        &self,
    ) -> sails_rs::client::Service<vft_native_exchange::VftNativeExchangeImpl, Self::Env>;
    fn vft_native_exchange_admin(
        &self,
    ) -> sails_rs::client::Service<vft_native_exchange_admin::VftNativeExchangeAdminImpl, Self::Env>;
}

impl<E: sails_rs::client::GearEnv> VftPackTestClient
    for sails_rs::client::Actor<VftPackTestClientProgram, E>
{
    type Env = E;
    fn test(&self) -> sails_rs::client::Service<test::TestImpl, Self::Env> {
        self.service(stringify!(Test))
    }
    fn vft(&self) -> sails_rs::client::Service<vft::VftImpl, Self::Env> {
        self.service(stringify!(Vft))
    }
    fn vft_admin(&self) -> sails_rs::client::Service<vft_admin::VftAdminImpl, Self::Env> {
        self.service(stringify!(VftAdmin))
    }
    fn vft_extension(
        &self,
    ) -> sails_rs::client::Service<vft_extension::VftExtensionImpl, Self::Env> {
        self.service(stringify!(VftExtension))
    }
    fn vft_metadata(&self) -> sails_rs::client::Service<vft_metadata::VftMetadataImpl, Self::Env> {
        self.service(stringify!(VftMetadata))
    }
    fn vft_native_exchange(
        &self,
    ) -> sails_rs::client::Service<vft_native_exchange::VftNativeExchangeImpl, Self::Env> {
        self.service(stringify!(VftNativeExchange))
    }
    fn vft_native_exchange_admin(
        &self,
    ) -> sails_rs::client::Service<vft_native_exchange_admin::VftNativeExchangeAdminImpl, Self::Env>
    {
        self.service(stringify!(VftNativeExchangeAdmin))
    }
}

pub trait VftPackTestClientCtors {
    type Env: sails_rs::client::GearEnv;
    #[allow(clippy::new_ret_no_self)]
    #[allow(clippy::wrong_self_convention)]
    fn new(self) -> sails_rs::client::PendingCtor<VftPackTestClientProgram, io::New, Self::Env>;
}

impl<E: sails_rs::client::GearEnv> VftPackTestClientCtors
    for sails_rs::client::Deployment<VftPackTestClientProgram, E>
{
    type Env = E;
    fn new(self) -> sails_rs::client::PendingCtor<VftPackTestClientProgram, io::New, Self::Env> {
        self.pending_ctor(())
    }
}

pub mod io {
    use super::*;
    sails_rs::io_struct_impl!(New () -> ());
}

pub mod test {
    use super::*;

    pub trait Test {
        type Env: sails_rs::client::GearEnv;
        fn set(
            &mut self,
            new_allowances: Vec<(ActorId, ActorId, U256, u32)>,
            new_balances: Vec<(ActorId, U256)>,
            expiry_period: u32,
        ) -> sails_rs::client::PendingCall<io::Set, Self::Env>;
    }

    pub struct TestImpl;

    impl<E: sails_rs::client::GearEnv> Test for sails_rs::client::Service<TestImpl, E> {
        type Env = E;
        fn set(
            &mut self,
            new_allowances: Vec<(ActorId, ActorId, U256, u32)>,
            new_balances: Vec<(ActorId, U256)>,
            expiry_period: u32,
        ) -> sails_rs::client::PendingCall<io::Set, Self::Env> {
            self.pending_call((new_allowances, new_balances, expiry_period))
        }
    }

    pub mod io {
        use super::*;
        sails_rs::io_struct_impl!(Set (new_allowances: Vec<(ActorId,ActorId,U256,u32,)>, new_balances: Vec<(ActorId,U256,)>, expiry_period: u32) -> ());
    }
}

pub mod vft {
    use super::*;

    pub trait Vft {
        type Env: sails_rs::client::GearEnv;
        fn approve(
            &mut self,
            spender: ActorId,
            value: U256,
        ) -> sails_rs::client::PendingCall<io::Approve, Self::Env>;
        fn transfer(
            &mut self,
            to: ActorId,
            value: U256,
        ) -> sails_rs::client::PendingCall<io::Transfer, Self::Env>;
        fn transfer_from(
            &mut self,
            from: ActorId,
            to: ActorId,
            value: U256,
        ) -> sails_rs::client::PendingCall<io::TransferFrom, Self::Env>;
        fn allowance(
            &self,
            owner: ActorId,
            spender: ActorId,
        ) -> sails_rs::client::PendingCall<io::Allowance, Self::Env>;
        fn balance_of(
            &self,
            account: ActorId,
        ) -> sails_rs::client::PendingCall<io::BalanceOf, Self::Env>;
        fn total_supply(&self) -> sails_rs::client::PendingCall<io::TotalSupply, Self::Env>;
    }

    pub struct VftImpl;

    impl<E: sails_rs::client::GearEnv> Vft for sails_rs::client::Service<VftImpl, E> {
        type Env = E;
        fn approve(
            &mut self,
            spender: ActorId,
            value: U256,
        ) -> sails_rs::client::PendingCall<io::Approve, Self::Env> {
            self.pending_call((spender, value))
        }
        fn transfer(
            &mut self,
            to: ActorId,
            value: U256,
        ) -> sails_rs::client::PendingCall<io::Transfer, Self::Env> {
            self.pending_call((to, value))
        }
        fn transfer_from(
            &mut self,
            from: ActorId,
            to: ActorId,
            value: U256,
        ) -> sails_rs::client::PendingCall<io::TransferFrom, Self::Env> {
            self.pending_call((from, to, value))
        }
        fn allowance(
            &self,
            owner: ActorId,
            spender: ActorId,
        ) -> sails_rs::client::PendingCall<io::Allowance, Self::Env> {
            self.pending_call((owner, spender))
        }
        fn balance_of(
            &self,
            account: ActorId,
        ) -> sails_rs::client::PendingCall<io::BalanceOf, Self::Env> {
            self.pending_call((account,))
        }
        fn total_supply(&self) -> sails_rs::client::PendingCall<io::TotalSupply, Self::Env> {
            self.pending_call(())
        }
    }

    pub mod io {
        use super::*;
        sails_rs::io_struct_impl!(Approve (spender: ActorId, value: U256) -> bool);
        sails_rs::io_struct_impl!(Transfer (to: ActorId, value: U256) -> bool);
        sails_rs::io_struct_impl!(TransferFrom (from: ActorId, to: ActorId, value: U256) -> bool);
        sails_rs::io_struct_impl!(Allowance (owner: ActorId, spender: ActorId) -> U256);
        sails_rs::io_struct_impl!(BalanceOf (account: ActorId) -> U256);
        sails_rs::io_struct_impl!(TotalSupply () -> U256);
    }

    #[cfg(not(target_arch = "wasm32"))]
    pub mod events {
        use super::*;
        #[derive(PartialEq, Debug, Encode, Decode)]
        #[codec(crate = sails_rs::scale_codec)]
        pub enum VftEvents {
            Approval {
                owner: ActorId,
                spender: ActorId,
                value: U256,
            },
            Transfer {
                from: ActorId,
                to: ActorId,
                value: U256,
            },
        }
        impl sails_rs::client::Event for VftEvents {
            const EVENT_NAMES: &'static [Route] = &["Approval", "Transfer"];
        }

        impl sails_rs::client::ServiceWithEvents for VftImpl {
            type Event = VftEvents;
        }
    }
}

pub mod vft_admin {
    use super::*;

    pub trait VftAdmin {
        type Env: sails_rs::client::GearEnv;
        fn append_allowances_shard(
            &mut self,
            capacity: u32,
        ) -> sails_rs::client::PendingCall<io::AppendAllowancesShard, Self::Env>;
        fn append_balances_shard(
            &mut self,
            capacity: u32,
        ) -> sails_rs::client::PendingCall<io::AppendBalancesShard, Self::Env>;
        fn approve_from(
            &mut self,
            owner: ActorId,
            spender: ActorId,
            value: U256,
        ) -> sails_rs::client::PendingCall<io::ApproveFrom, Self::Env>;
        fn burn(
            &mut self,
            from: ActorId,
            value: U256,
        ) -> sails_rs::client::PendingCall<io::Burn, Self::Env>;
        fn exit(
            &mut self,
            inheritor: ActorId,
        ) -> sails_rs::client::PendingCall<io::Exit, Self::Env>;
        fn mint(
            &mut self,
            to: ActorId,
            value: U256,
        ) -> sails_rs::client::PendingCall<io::Mint, Self::Env>;
        fn pause(&mut self) -> sails_rs::client::PendingCall<io::Pause, Self::Env>;
        fn resume(&mut self) -> sails_rs::client::PendingCall<io::Resume, Self::Env>;
        fn set_admin(
            &mut self,
            admin: ActorId,
        ) -> sails_rs::client::PendingCall<io::SetAdmin, Self::Env>;
        fn set_burner(
            &mut self,
            burner: ActorId,
        ) -> sails_rs::client::PendingCall<io::SetBurner, Self::Env>;
        fn set_expiry_period(
            &mut self,
            period: u32,
        ) -> sails_rs::client::PendingCall<io::SetExpiryPeriod, Self::Env>;
        fn set_minter(
            &mut self,
            minter: ActorId,
        ) -> sails_rs::client::PendingCall<io::SetMinter, Self::Env>;
        fn set_pauser(
            &mut self,
            pauser: ActorId,
        ) -> sails_rs::client::PendingCall<io::SetPauser, Self::Env>;
        fn admin(&self) -> sails_rs::client::PendingCall<io::Admin, Self::Env>;
        fn burner(&self) -> sails_rs::client::PendingCall<io::Burner, Self::Env>;
        fn is_paused(&self) -> sails_rs::client::PendingCall<io::IsPaused, Self::Env>;
        fn minter(&self) -> sails_rs::client::PendingCall<io::Minter, Self::Env>;
        fn pauser(&self) -> sails_rs::client::PendingCall<io::Pauser, Self::Env>;
    }

    pub struct VftAdminImpl;

    impl<E: sails_rs::client::GearEnv> VftAdmin for sails_rs::client::Service<VftAdminImpl, E> {
        type Env = E;
        fn append_allowances_shard(
            &mut self,
            capacity: u32,
        ) -> sails_rs::client::PendingCall<io::AppendAllowancesShard, Self::Env> {
            self.pending_call((capacity,))
        }
        fn append_balances_shard(
            &mut self,
            capacity: u32,
        ) -> sails_rs::client::PendingCall<io::AppendBalancesShard, Self::Env> {
            self.pending_call((capacity,))
        }
        fn approve_from(
            &mut self,
            owner: ActorId,
            spender: ActorId,
            value: U256,
        ) -> sails_rs::client::PendingCall<io::ApproveFrom, Self::Env> {
            self.pending_call((owner, spender, value))
        }
        fn burn(
            &mut self,
            from: ActorId,
            value: U256,
        ) -> sails_rs::client::PendingCall<io::Burn, Self::Env> {
            self.pending_call((from, value))
        }
        fn exit(
            &mut self,
            inheritor: ActorId,
        ) -> sails_rs::client::PendingCall<io::Exit, Self::Env> {
            self.pending_call((inheritor,))
        }
        fn mint(
            &mut self,
            to: ActorId,
            value: U256,
        ) -> sails_rs::client::PendingCall<io::Mint, Self::Env> {
            self.pending_call((to, value))
        }
        fn pause(&mut self) -> sails_rs::client::PendingCall<io::Pause, Self::Env> {
            self.pending_call(())
        }
        fn resume(&mut self) -> sails_rs::client::PendingCall<io::Resume, Self::Env> {
            self.pending_call(())
        }
        fn set_admin(
            &mut self,
            admin: ActorId,
        ) -> sails_rs::client::PendingCall<io::SetAdmin, Self::Env> {
            self.pending_call((admin,))
        }
        fn set_burner(
            &mut self,
            burner: ActorId,
        ) -> sails_rs::client::PendingCall<io::SetBurner, Self::Env> {
            self.pending_call((burner,))
        }
        fn set_expiry_period(
            &mut self,
            period: u32,
        ) -> sails_rs::client::PendingCall<io::SetExpiryPeriod, Self::Env> {
            self.pending_call((period,))
        }
        fn set_minter(
            &mut self,
            minter: ActorId,
        ) -> sails_rs::client::PendingCall<io::SetMinter, Self::Env> {
            self.pending_call((minter,))
        }
        fn set_pauser(
            &mut self,
            pauser: ActorId,
        ) -> sails_rs::client::PendingCall<io::SetPauser, Self::Env> {
            self.pending_call((pauser,))
        }
        fn admin(&self) -> sails_rs::client::PendingCall<io::Admin, Self::Env> {
            self.pending_call(())
        }
        fn burner(&self) -> sails_rs::client::PendingCall<io::Burner, Self::Env> {
            self.pending_call(())
        }
        fn is_paused(&self) -> sails_rs::client::PendingCall<io::IsPaused, Self::Env> {
            self.pending_call(())
        }
        fn minter(&self) -> sails_rs::client::PendingCall<io::Minter, Self::Env> {
            self.pending_call(())
        }
        fn pauser(&self) -> sails_rs::client::PendingCall<io::Pauser, Self::Env> {
            self.pending_call(())
        }
    }

    pub mod io {
        use super::*;
        sails_rs::io_struct_impl!(AppendAllowancesShard (capacity: u32) -> ());
        sails_rs::io_struct_impl!(AppendBalancesShard (capacity: u32) -> ());
        sails_rs::io_struct_impl!(ApproveFrom (owner: ActorId, spender: ActorId, value: U256) -> bool);
        sails_rs::io_struct_impl!(Burn (from: ActorId, value: U256) -> ());
        sails_rs::io_struct_impl!(Exit (inheritor: ActorId) -> ());
        sails_rs::io_struct_impl!(Mint (to: ActorId, value: U256) -> ());
        sails_rs::io_struct_impl!(Pause () -> ());
        sails_rs::io_struct_impl!(Resume () -> ());
        sails_rs::io_struct_impl!(SetAdmin (admin: ActorId) -> ());
        sails_rs::io_struct_impl!(SetBurner (burner: ActorId) -> ());
        sails_rs::io_struct_impl!(SetExpiryPeriod (period: u32) -> ());
        sails_rs::io_struct_impl!(SetMinter (minter: ActorId) -> ());
        sails_rs::io_struct_impl!(SetPauser (pauser: ActorId) -> ());
        sails_rs::io_struct_impl!(Admin () -> ActorId);
        sails_rs::io_struct_impl!(Burner () -> ActorId);
        sails_rs::io_struct_impl!(IsPaused () -> bool);
        sails_rs::io_struct_impl!(Minter () -> ActorId);
        sails_rs::io_struct_impl!(Pauser () -> ActorId);
    }

    #[cfg(not(target_arch = "wasm32"))]
    pub mod events {
        use super::*;
        #[derive(PartialEq, Debug, Encode, Decode)]
        #[codec(crate = sails_rs::scale_codec)]
        pub enum VftAdminEvents {
            AdminChanged(ActorId),
            BurnerChanged(ActorId),
            MinterChanged(ActorId),
            PauserChanged(ActorId),
            BurnerTookPlace,
            MinterTookPlace,
            ExpiryPeriodChanged(u32),
            Exited(ActorId),
            Paused,
            Resumed,
        }
        impl sails_rs::client::Event for VftAdminEvents {
            const EVENT_NAMES: &'static [Route] = &[
                "AdminChanged",
                "BurnerChanged",
                "MinterChanged",
                "PauserChanged",
                "BurnerTookPlace",
                "MinterTookPlace",
                "ExpiryPeriodChanged",
                "Exited",
                "Paused",
                "Resumed",
            ];
        }

        impl sails_rs::client::ServiceWithEvents for VftAdminImpl {
            type Event = VftAdminEvents;
        }
    }
}

pub mod vft_extension {
    use super::*;

    pub trait VftExtension {
        type Env: sails_rs::client::GearEnv;
        fn allocate_next_allowances_shard(
            &mut self,
        ) -> sails_rs::client::PendingCall<io::AllocateNextAllowancesShard, Self::Env>;
        fn allocate_next_balances_shard(
            &mut self,
        ) -> sails_rs::client::PendingCall<io::AllocateNextBalancesShard, Self::Env>;
        fn remove_expired_allowance(
            &mut self,
            owner: ActorId,
            spender: ActorId,
        ) -> sails_rs::client::PendingCall<io::RemoveExpiredAllowance, Self::Env>;
        fn transfer_all(
            &mut self,
            to: ActorId,
        ) -> sails_rs::client::PendingCall<io::TransferAll, Self::Env>;
        fn transfer_all_from(
            &mut self,
            from: ActorId,
            to: ActorId,
        ) -> sails_rs::client::PendingCall<io::TransferAllFrom, Self::Env>;
        fn allowance_of(
            &self,
            owner: ActorId,
            spender: ActorId,
        ) -> sails_rs::client::PendingCall<io::AllowanceOf, Self::Env>;
        fn allowances(
            &self,
            cursor: u32,
            len: u32,
        ) -> sails_rs::client::PendingCall<io::Allowances, Self::Env>;
        fn balance_of(
            &self,
            account: ActorId,
        ) -> sails_rs::client::PendingCall<io::BalanceOf, Self::Env>;
        fn balances(
            &self,
            cursor: u32,
            len: u32,
        ) -> sails_rs::client::PendingCall<io::Balances, Self::Env>;
        fn expiry_period(&self) -> sails_rs::client::PendingCall<io::ExpiryPeriod, Self::Env>;
        fn unused_value(&self) -> sails_rs::client::PendingCall<io::UnusedValue, Self::Env>;
    }

    pub struct VftExtensionImpl;

    impl<E: sails_rs::client::GearEnv> VftExtension for sails_rs::client::Service<VftExtensionImpl, E> {
        type Env = E;
        fn allocate_next_allowances_shard(
            &mut self,
        ) -> sails_rs::client::PendingCall<io::AllocateNextAllowancesShard, Self::Env> {
            self.pending_call(())
        }
        fn allocate_next_balances_shard(
            &mut self,
        ) -> sails_rs::client::PendingCall<io::AllocateNextBalancesShard, Self::Env> {
            self.pending_call(())
        }
        fn remove_expired_allowance(
            &mut self,
            owner: ActorId,
            spender: ActorId,
        ) -> sails_rs::client::PendingCall<io::RemoveExpiredAllowance, Self::Env> {
            self.pending_call((owner, spender))
        }
        fn transfer_all(
            &mut self,
            to: ActorId,
        ) -> sails_rs::client::PendingCall<io::TransferAll, Self::Env> {
            self.pending_call((to,))
        }
        fn transfer_all_from(
            &mut self,
            from: ActorId,
            to: ActorId,
        ) -> sails_rs::client::PendingCall<io::TransferAllFrom, Self::Env> {
            self.pending_call((from, to))
        }
        fn allowance_of(
            &self,
            owner: ActorId,
            spender: ActorId,
        ) -> sails_rs::client::PendingCall<io::AllowanceOf, Self::Env> {
            self.pending_call((owner, spender))
        }
        fn allowances(
            &self,
            cursor: u32,
            len: u32,
        ) -> sails_rs::client::PendingCall<io::Allowances, Self::Env> {
            self.pending_call((cursor, len))
        }
        fn balance_of(
            &self,
            account: ActorId,
        ) -> sails_rs::client::PendingCall<io::BalanceOf, Self::Env> {
            self.pending_call((account,))
        }
        fn balances(
            &self,
            cursor: u32,
            len: u32,
        ) -> sails_rs::client::PendingCall<io::Balances, Self::Env> {
            self.pending_call((cursor, len))
        }
        fn expiry_period(&self) -> sails_rs::client::PendingCall<io::ExpiryPeriod, Self::Env> {
            self.pending_call(())
        }
        fn unused_value(&self) -> sails_rs::client::PendingCall<io::UnusedValue, Self::Env> {
            self.pending_call(())
        }
    }

    pub mod io {
        use super::*;
        sails_rs::io_struct_impl!(AllocateNextAllowancesShard () -> bool);
        sails_rs::io_struct_impl!(AllocateNextBalancesShard () -> bool);
        sails_rs::io_struct_impl!(RemoveExpiredAllowance (owner: ActorId, spender: ActorId) -> bool);
        sails_rs::io_struct_impl!(TransferAll (to: ActorId) -> bool);
        sails_rs::io_struct_impl!(TransferAllFrom (from: ActorId, to: ActorId) -> bool);
        sails_rs::io_struct_impl!(AllowanceOf (owner: ActorId, spender: ActorId) -> Option<(U256,u32,)>);
        sails_rs::io_struct_impl!(Allowances (cursor: u32, len: u32) -> Vec<((ActorId,ActorId,),(U256,u32,),)>);
        sails_rs::io_struct_impl!(BalanceOf (account: ActorId) -> Option<U256>);
        sails_rs::io_struct_impl!(Balances (cursor: u32, len: u32) -> Vec<(ActorId,U256,)>);
        sails_rs::io_struct_impl!(ExpiryPeriod () -> u32);
        sails_rs::io_struct_impl!(UnusedValue () -> U256);
    }
}

pub mod vft_metadata {
    use super::*;

    pub trait VftMetadata {
        type Env: sails_rs::client::GearEnv;
        /// Returns the number of decimals of the VFT.
        fn decimals(&self) -> sails_rs::client::PendingCall<io::Decimals, Self::Env>;
        /// Returns the name of the VFT.
        fn name(&self) -> sails_rs::client::PendingCall<io::Name, Self::Env>;
        /// Returns the symbol of the VFT.
        fn symbol(&self) -> sails_rs::client::PendingCall<io::Symbol, Self::Env>;
    }

    pub struct VftMetadataImpl;

    impl<E: sails_rs::client::GearEnv> VftMetadata for sails_rs::client::Service<VftMetadataImpl, E> {
        type Env = E;
        fn decimals(&self) -> sails_rs::client::PendingCall<io::Decimals, Self::Env> {
            self.pending_call(())
        }
        fn name(&self) -> sails_rs::client::PendingCall<io::Name, Self::Env> {
            self.pending_call(())
        }
        fn symbol(&self) -> sails_rs::client::PendingCall<io::Symbol, Self::Env> {
            self.pending_call(())
        }
    }

    pub mod io {
        use super::*;
        sails_rs::io_struct_impl!(Decimals () -> u8);
        sails_rs::io_struct_impl!(Name () -> String);
        sails_rs::io_struct_impl!(Symbol () -> String);
    }
}

pub mod vft_native_exchange {
    use super::*;

    pub trait VftNativeExchange {
        type Env: sails_rs::client::GearEnv;
        fn burn(&mut self, value: U256) -> sails_rs::client::PendingCall<io::Burn, Self::Env>;
        fn burn_all(&mut self) -> sails_rs::client::PendingCall<io::BurnAll, Self::Env>;
        fn mint(&mut self) -> sails_rs::client::PendingCall<io::Mint, Self::Env>;
    }

    pub struct VftNativeExchangeImpl;

    impl<E: sails_rs::client::GearEnv> VftNativeExchange
        for sails_rs::client::Service<VftNativeExchangeImpl, E>
    {
        type Env = E;
        fn burn(&mut self, value: U256) -> sails_rs::client::PendingCall<io::Burn, Self::Env> {
            self.pending_call((value,))
        }
        fn burn_all(&mut self) -> sails_rs::client::PendingCall<io::BurnAll, Self::Env> {
            self.pending_call(())
        }
        fn mint(&mut self) -> sails_rs::client::PendingCall<io::Mint, Self::Env> {
            self.pending_call(())
        }
    }

    pub mod io {
        use super::*;
        sails_rs::io_struct_impl!(Burn (value: U256) -> ());
        sails_rs::io_struct_impl!(BurnAll () -> ());
        sails_rs::io_struct_impl!(Mint () -> ());
    }
}

pub mod vft_native_exchange_admin {
    use super::*;

    pub trait VftNativeExchangeAdmin {
        type Env: sails_rs::client::GearEnv;
        fn burn_from(
            &mut self,
            from: ActorId,
            value: U256,
        ) -> sails_rs::client::PendingCall<io::BurnFrom, Self::Env>;
    }

    pub struct VftNativeExchangeAdminImpl;

    impl<E: sails_rs::client::GearEnv> VftNativeExchangeAdmin
        for sails_rs::client::Service<VftNativeExchangeAdminImpl, E>
    {
        type Env = E;
        fn burn_from(
            &mut self,
            from: ActorId,
            value: U256,
        ) -> sails_rs::client::PendingCall<io::BurnFrom, Self::Env> {
            self.pending_call((from, value))
        }
    }

    pub mod io {
        use super::*;
        sails_rs::io_struct_impl!(BurnFrom (from: ActorId, value: U256) -> ());
    }

    #[cfg(not(target_arch = "wasm32"))]
    pub mod events {
        use super::*;
        #[derive(PartialEq, Debug, Encode, Decode)]
        #[codec(crate = sails_rs::scale_codec)]
        pub enum VftNativeExchangeAdminEvents {
            FailedMint { to: ActorId, value: U256 },
        }
        impl sails_rs::client::Event for VftNativeExchangeAdminEvents {
            const EVENT_NAMES: &'static [Route] = &["FailedMint"];
        }

        impl sails_rs::client::ServiceWithEvents for VftNativeExchangeAdminImpl {
            type Event = VftNativeExchangeAdminEvents;
        }
    }
}
