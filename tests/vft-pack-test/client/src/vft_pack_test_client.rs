// Code generated by sails-client-gen. DO NOT EDIT.
#[allow(unused_imports)]
use sails_rs::{client::*, collections::*, prelude::*};
pub struct VftPackTestClientProgram;
impl sails_rs::client::Program for VftPackTestClientProgram {}
pub trait VftPackTestClient {
    type Env: sails_rs::client::GearEnv;
    fn test(&self) -> sails_rs::client::Service<test::TestImpl, Self::Env>;
    fn access_control(
        &self,
    ) -> sails_rs::client::Service<access_control::AccessControlImpl, Self::Env>;
    fn vft(&self) -> sails_rs::client::Service<vft::VftImpl, Self::Env>;
    fn vft_admin(&self) -> sails_rs::client::Service<vft_admin::VftAdminImpl, Self::Env>;
    fn vft_extension(
        &self,
    ) -> sails_rs::client::Service<vft_extension::VftExtensionImpl, Self::Env>;
    fn vft_metadata(&self) -> sails_rs::client::Service<vft_metadata::VftMetadataImpl, Self::Env>;
    fn vft_native_exchange(
        &self,
    ) -> sails_rs::client::Service<vft_native_exchange::VftNativeExchangeImpl, Self::Env>;
    fn vft_native_exchange_admin(
        &self,
    ) -> sails_rs::client::Service<vft_native_exchange_admin::VftNativeExchangeAdminImpl, Self::Env>;
}
impl<E: sails_rs::client::GearEnv> VftPackTestClient
    for sails_rs::client::Actor<VftPackTestClientProgram, E>
{
    type Env = E;
    fn test(&self) -> sails_rs::client::Service<test::TestImpl, Self::Env> {
        self.service(stringify!(Test))
    }
    fn access_control(
        &self,
    ) -> sails_rs::client::Service<access_control::AccessControlImpl, Self::Env> {
        self.service(stringify!(AccessControl))
    }
    fn vft(&self) -> sails_rs::client::Service<vft::VftImpl, Self::Env> {
        self.service(stringify!(Vft))
    }
    fn vft_admin(&self) -> sails_rs::client::Service<vft_admin::VftAdminImpl, Self::Env> {
        self.service(stringify!(VftAdmin))
    }
    fn vft_extension(
        &self,
    ) -> sails_rs::client::Service<vft_extension::VftExtensionImpl, Self::Env> {
        self.service(stringify!(VftExtension))
    }
    fn vft_metadata(&self) -> sails_rs::client::Service<vft_metadata::VftMetadataImpl, Self::Env> {
        self.service(stringify!(VftMetadata))
    }
    fn vft_native_exchange(
        &self,
    ) -> sails_rs::client::Service<vft_native_exchange::VftNativeExchangeImpl, Self::Env> {
        self.service(stringify!(VftNativeExchange))
    }
    fn vft_native_exchange_admin(
        &self,
    ) -> sails_rs::client::Service<vft_native_exchange_admin::VftNativeExchangeAdminImpl, Self::Env>
    {
        self.service(stringify!(VftNativeExchangeAdmin))
    }
}
pub trait VftPackTestClientCtors {
    type Env: sails_rs::client::GearEnv;
    #[allow(clippy::new_ret_no_self)]
    #[allow(clippy::wrong_self_convention)]
    fn new(self) -> sails_rs::client::PendingCtor<VftPackTestClientProgram, io::New, Self::Env>;
}
impl<E: sails_rs::client::GearEnv> VftPackTestClientCtors
    for sails_rs::client::Deployment<VftPackTestClientProgram, E>
{
    type Env = E;
    fn new(self) -> sails_rs::client::PendingCtor<VftPackTestClientProgram, io::New, Self::Env> {
        self.pending_ctor(())
    }
}

pub mod io {
    use super::*;
    sails_rs::io_struct_impl!(New () -> ());
}

pub mod test {
    use super::*;
    pub trait Test {
        type Env: sails_rs::client::GearEnv;
        fn set(
            &mut self,
            new_allowances: Vec<(ActorId, ActorId, U256, u32)>,
            new_balances: Vec<(ActorId, U256)>,
            expiry_period: u32,
        ) -> sails_rs::client::PendingCall<io::Set, Self::Env>;
    }
    pub struct TestImpl;
    impl<E: sails_rs::client::GearEnv> Test for sails_rs::client::Service<TestImpl, E> {
        type Env = E;
        fn set(
            &mut self,
            new_allowances: Vec<(ActorId, ActorId, U256, u32)>,
            new_balances: Vec<(ActorId, U256)>,
            expiry_period: u32,
        ) -> sails_rs::client::PendingCall<io::Set, Self::Env> {
            self.pending_call((new_allowances, new_balances, expiry_period))
        }
    }

    pub mod io {
        use super::*;
        sails_rs::io_struct_impl!(Set (new_allowances: Vec<(ActorId,ActorId,U256,u32,)>, new_balances: Vec<(ActorId,U256,)>, expiry_period: u32) -> ());
    }
}

pub mod access_control {
    use super::*;
    pub trait AccessControl {
        type Env: sails_rs::client::GearEnv;
        /// Grants `role_id` to `target_account`.
        ///
        /// If `target_account` had not been already granted `role_id`, emits a `RoleGranted`
        /// event.
        ///
        /// Requirements:
        ///
        /// - the caller must have `role_id`'s admin role.
        fn grant_role(
            &mut self,
            role_id: [u8; 32],
            target_account: ActorId,
        ) -> sails_rs::client::PendingCall<io::GrantRole, Self::Env>;
        /// Grants `role_ids` to `target_account`.
        ///
        /// If `target_account` had not been already granted any of the `role_ids`,
        /// emits a `RoleGranted` event for each newly granted role.
        ///
        /// Requirements:
        ///
        /// - the caller must have the admin role for all specified `role_ids`.
        fn grant_roles_batch(
            &mut self,
            role_ids: Vec<[u8; 32]>,
            target_account: ActorId,
        ) -> sails_rs::client::PendingCall<io::GrantRolesBatch, Self::Env>;
        /// Revokes `role_id` from the calling account.
        ///
        /// Roles are often managed via `grant_role` and `revoke_role`: this function's
        /// purpose is to provide a mechanism for accounts to lose their privileges
        /// if they are compromised (such as when a trusted device is misplaced).
        ///
        /// If the calling account had been granted `role_id`, emits a `RoleRevoked`
        /// event.
        ///
        /// Requirements:
        ///
        /// - the caller must be `account_id`.
        fn renounce_role(
            &mut self,
            role_id: [u8; 32],
            account_id: ActorId,
        ) -> sails_rs::client::PendingCall<io::RenounceRole, Self::Env>;
        /// Revokes `role_id` from `target_account`.
        ///
        /// If `target_account` had been granted `role_id`, emits a `RoleRevoked` event.
        ///
        /// Requirements:
        ///
        /// - the caller must have `role_id`'s admin role.
        fn revoke_role(
            &mut self,
            role_id: [u8; 32],
            target_account: ActorId,
        ) -> sails_rs::client::PendingCall<io::RevokeRole, Self::Env>;
        /// Revokes `role_ids` from `target_account`.
        ///
        /// If `target_account` had been granted any of the `role_ids`,
        /// emits a `RoleRevoked` event for each newly revoked role.
        ///
        /// Requirements:
        ///
        /// - the caller must have the admin role for all specified `role_ids`.
        fn revoke_roles_batch(
            &mut self,
            role_ids: Vec<[u8; 32]>,
            target_account: ActorId,
        ) -> sails_rs::client::PendingCall<io::RevokeRolesBatch, Self::Env>;
        /// Sets `new_admin_role_id` as the admin role for `role_id`.
        ///
        /// Emits a `RoleAdminChanged` event.
        ///
        /// Requirements:
        ///
        /// - the caller must have `role_id`'s admin role.
        fn set_role_admin(
            &mut self,
            role_id: [u8; 32],
            new_admin_role_id: [u8; 32],
        ) -> sails_rs::client::PendingCall<io::SetRoleAdmin, Self::Env>;
        /// Returns the admin role ID that controls `role_id`.
        fn get_role_admin(
            &self,
            role_id: [u8; 32],
        ) -> sails_rs::client::PendingCall<io::GetRoleAdmin, Self::Env>;
        /// Returns the number of roles in the system.
        fn get_role_count(&self) -> sails_rs::client::PendingCall<io::GetRoleCount, Self::Env>;
        /// Returns the role ID at the specified index.
        fn get_role_id(
            &self,
            index: u32,
        ) -> sails_rs::client::PendingCall<io::GetRoleId, Self::Env>;
        /// Returns the member at the specified index in the specified role.
        fn get_role_member(
            &self,
            role_id: [u8; 32],
            index: u32,
        ) -> sails_rs::client::PendingCall<io::GetRoleMember, Self::Env>;
        /// Returns the number of members in the specified role.
        fn get_role_member_count(
            &self,
            role_id: [u8; 32],
        ) -> sails_rs::client::PendingCall<io::GetRoleMemberCount, Self::Env>;
        /// Returns `true` if `account_id` has been granted `role_id`.
        fn has_role(
            &self,
            role_id: [u8; 32],
            account_id: ActorId,
        ) -> sails_rs::client::PendingCall<io::HasRole, Self::Env>;
    }
    pub struct AccessControlImpl;
    impl<E: sails_rs::client::GearEnv> AccessControl
        for sails_rs::client::Service<AccessControlImpl, E>
    {
        type Env = E;
        fn grant_role(
            &mut self,
            role_id: [u8; 32],
            target_account: ActorId,
        ) -> sails_rs::client::PendingCall<io::GrantRole, Self::Env> {
            self.pending_call((role_id, target_account))
        }
        fn grant_roles_batch(
            &mut self,
            role_ids: Vec<[u8; 32]>,
            target_account: ActorId,
        ) -> sails_rs::client::PendingCall<io::GrantRolesBatch, Self::Env> {
            self.pending_call((role_ids, target_account))
        }
        fn renounce_role(
            &mut self,
            role_id: [u8; 32],
            account_id: ActorId,
        ) -> sails_rs::client::PendingCall<io::RenounceRole, Self::Env> {
            self.pending_call((role_id, account_id))
        }
        fn revoke_role(
            &mut self,
            role_id: [u8; 32],
            target_account: ActorId,
        ) -> sails_rs::client::PendingCall<io::RevokeRole, Self::Env> {
            self.pending_call((role_id, target_account))
        }
        fn revoke_roles_batch(
            &mut self,
            role_ids: Vec<[u8; 32]>,
            target_account: ActorId,
        ) -> sails_rs::client::PendingCall<io::RevokeRolesBatch, Self::Env> {
            self.pending_call((role_ids, target_account))
        }
        fn set_role_admin(
            &mut self,
            role_id: [u8; 32],
            new_admin_role_id: [u8; 32],
        ) -> sails_rs::client::PendingCall<io::SetRoleAdmin, Self::Env> {
            self.pending_call((role_id, new_admin_role_id))
        }
        fn get_role_admin(
            &self,
            role_id: [u8; 32],
        ) -> sails_rs::client::PendingCall<io::GetRoleAdmin, Self::Env> {
            self.pending_call((role_id,))
        }
        fn get_role_count(&self) -> sails_rs::client::PendingCall<io::GetRoleCount, Self::Env> {
            self.pending_call(())
        }
        fn get_role_id(
            &self,
            index: u32,
        ) -> sails_rs::client::PendingCall<io::GetRoleId, Self::Env> {
            self.pending_call((index,))
        }
        fn get_role_member(
            &self,
            role_id: [u8; 32],
            index: u32,
        ) -> sails_rs::client::PendingCall<io::GetRoleMember, Self::Env> {
            self.pending_call((role_id, index))
        }
        fn get_role_member_count(
            &self,
            role_id: [u8; 32],
        ) -> sails_rs::client::PendingCall<io::GetRoleMemberCount, Self::Env> {
            self.pending_call((role_id,))
        }
        fn has_role(
            &self,
            role_id: [u8; 32],
            account_id: ActorId,
        ) -> sails_rs::client::PendingCall<io::HasRole, Self::Env> {
            self.pending_call((role_id, account_id))
        }
    }

    pub mod io {
        use super::*;
        sails_rs::io_struct_impl!(GrantRole (role_id: [u8; 32], target_account: ActorId) -> ());
        sails_rs::io_struct_impl!(GrantRolesBatch (role_ids: Vec<[u8; 32]>, target_account: ActorId) -> ());
        sails_rs::io_struct_impl!(RenounceRole (role_id: [u8; 32], account_id: ActorId) -> ());
        sails_rs::io_struct_impl!(RevokeRole (role_id: [u8; 32], target_account: ActorId) -> ());
        sails_rs::io_struct_impl!(RevokeRolesBatch (role_ids: Vec<[u8; 32]>, target_account: ActorId) -> ());
        sails_rs::io_struct_impl!(SetRoleAdmin (role_id: [u8; 32], new_admin_role_id: [u8; 32]) -> ());
        sails_rs::io_struct_impl!(GetRoleAdmin (role_id: [u8; 32]) -> [u8; 32]);
        sails_rs::io_struct_impl!(GetRoleCount () -> u32);
        sails_rs::io_struct_impl!(GetRoleId (index: u32) -> Option<[u8; 32]>);
        sails_rs::io_struct_impl!(GetRoleMember (role_id: [u8; 32], index: u32) -> Option<ActorId>);
        sails_rs::io_struct_impl!(GetRoleMemberCount (role_id: [u8; 32]) -> u32);
        sails_rs::io_struct_impl!(HasRole (role_id: [u8; 32], account_id: ActorId) -> bool);
    }

    #[cfg(not(target_arch = "wasm32"))]
    pub mod events {
        use super::*;
        #[derive(PartialEq, Debug, Encode, Decode)]
        #[codec(crate = sails_rs::scale_codec)]
        pub enum AccessControlEvents {
            RoleGranted {
                role_id: [u8; 32],
                target_account: ActorId,
                sender: ActorId,
            },
            RoleRevoked {
                role_id: [u8; 32],
                target_account: ActorId,
                sender: ActorId,
            },
            RoleAdminChanged {
                role_id: [u8; 32],
                previous_admin_role_id: [u8; 32],
                new_admin_role_id: [u8; 32],
                sender: ActorId,
            },
        }
        impl sails_rs::client::Event for AccessControlEvents {
            const EVENT_NAMES: &'static [Route] =
                &["RoleGranted", "RoleRevoked", "RoleAdminChanged"];
        }
        impl sails_rs::client::ServiceWithEvents for AccessControlImpl {
            type Event = AccessControlEvents;
        }
    }
}

pub mod vft {
    use super::*;
    pub trait Vft {
        type Env: sails_rs::client::GearEnv;
        fn approve(
            &mut self,
            spender: ActorId,
            value: U256,
        ) -> sails_rs::client::PendingCall<io::Approve, Self::Env>;
        fn transfer(
            &mut self,
            to: ActorId,
            value: U256,
        ) -> sails_rs::client::PendingCall<io::Transfer, Self::Env>;
        fn transfer_from(
            &mut self,
            from: ActorId,
            to: ActorId,
            value: U256,
        ) -> sails_rs::client::PendingCall<io::TransferFrom, Self::Env>;
        fn allowance(
            &self,
            owner: ActorId,
            spender: ActorId,
        ) -> sails_rs::client::PendingCall<io::Allowance, Self::Env>;
        fn balance_of(
            &self,
            account: ActorId,
        ) -> sails_rs::client::PendingCall<io::BalanceOf, Self::Env>;
        fn total_supply(&self) -> sails_rs::client::PendingCall<io::TotalSupply, Self::Env>;
    }
    pub struct VftImpl;
    impl<E: sails_rs::client::GearEnv> Vft for sails_rs::client::Service<VftImpl, E> {
        type Env = E;
        fn approve(
            &mut self,
            spender: ActorId,
            value: U256,
        ) -> sails_rs::client::PendingCall<io::Approve, Self::Env> {
            self.pending_call((spender, value))
        }
        fn transfer(
            &mut self,
            to: ActorId,
            value: U256,
        ) -> sails_rs::client::PendingCall<io::Transfer, Self::Env> {
            self.pending_call((to, value))
        }
        fn transfer_from(
            &mut self,
            from: ActorId,
            to: ActorId,
            value: U256,
        ) -> sails_rs::client::PendingCall<io::TransferFrom, Self::Env> {
            self.pending_call((from, to, value))
        }
        fn allowance(
            &self,
            owner: ActorId,
            spender: ActorId,
        ) -> sails_rs::client::PendingCall<io::Allowance, Self::Env> {
            self.pending_call((owner, spender))
        }
        fn balance_of(
            &self,
            account: ActorId,
        ) -> sails_rs::client::PendingCall<io::BalanceOf, Self::Env> {
            self.pending_call((account,))
        }
        fn total_supply(&self) -> sails_rs::client::PendingCall<io::TotalSupply, Self::Env> {
            self.pending_call(())
        }
    }

    pub mod io {
        use super::*;
        sails_rs::io_struct_impl!(Approve (spender: ActorId, value: U256) -> bool);
        sails_rs::io_struct_impl!(Transfer (to: ActorId, value: U256) -> bool);
        sails_rs::io_struct_impl!(TransferFrom (from: ActorId, to: ActorId, value: U256) -> bool);
        sails_rs::io_struct_impl!(Allowance (owner: ActorId, spender: ActorId) -> U256);
        sails_rs::io_struct_impl!(BalanceOf (account: ActorId) -> U256);
        sails_rs::io_struct_impl!(TotalSupply () -> U256);
    }

    #[cfg(not(target_arch = "wasm32"))]
    pub mod events {
        use super::*;
        #[derive(PartialEq, Debug, Encode, Decode)]
        #[codec(crate = sails_rs::scale_codec)]
        pub enum VftEvents {
            Approval {
                owner: ActorId,
                spender: ActorId,
                value: U256,
            },
            Transfer {
                from: ActorId,
                to: ActorId,
                value: U256,
            },
        }
        impl sails_rs::client::Event for VftEvents {
            const EVENT_NAMES: &'static [Route] = &["Approval", "Transfer"];
        }
        impl sails_rs::client::ServiceWithEvents for VftImpl {
            type Event = VftEvents;
        }
    }
}

pub mod vft_admin {
    use super::*;
    pub trait VftAdmin {
        type Env: sails_rs::client::GearEnv;
        fn append_allowances_shard(
            &mut self,
            capacity: u32,
        ) -> sails_rs::client::PendingCall<io::AppendAllowancesShard, Self::Env>;
        fn append_balances_shard(
            &mut self,
            capacity: u32,
        ) -> sails_rs::client::PendingCall<io::AppendBalancesShard, Self::Env>;
        fn approve_from(
            &mut self,
            owner: ActorId,
            spender: ActorId,
            value: U256,
        ) -> sails_rs::client::PendingCall<io::ApproveFrom, Self::Env>;
        fn burn(
            &mut self,
            from: ActorId,
            value: U256,
        ) -> sails_rs::client::PendingCall<io::Burn, Self::Env>;
        fn exit(
            &mut self,
            inheritor: ActorId,
        ) -> sails_rs::client::PendingCall<io::Exit, Self::Env>;
        fn mint(
            &mut self,
            to: ActorId,
            value: U256,
        ) -> sails_rs::client::PendingCall<io::Mint, Self::Env>;
        fn pause(&mut self) -> sails_rs::client::PendingCall<io::Pause, Self::Env>;
        fn resume(&mut self) -> sails_rs::client::PendingCall<io::Resume, Self::Env>;
        fn set_expiry_period(
            &mut self,
            period: u32,
        ) -> sails_rs::client::PendingCall<io::SetExpiryPeriod, Self::Env>;
        fn is_paused(&self) -> sails_rs::client::PendingCall<io::IsPaused, Self::Env>;
    }
    pub struct VftAdminImpl;
    impl<E: sails_rs::client::GearEnv> VftAdmin for sails_rs::client::Service<VftAdminImpl, E> {
        type Env = E;
        fn append_allowances_shard(
            &mut self,
            capacity: u32,
        ) -> sails_rs::client::PendingCall<io::AppendAllowancesShard, Self::Env> {
            self.pending_call((capacity,))
        }
        fn append_balances_shard(
            &mut self,
            capacity: u32,
        ) -> sails_rs::client::PendingCall<io::AppendBalancesShard, Self::Env> {
            self.pending_call((capacity,))
        }
        fn approve_from(
            &mut self,
            owner: ActorId,
            spender: ActorId,
            value: U256,
        ) -> sails_rs::client::PendingCall<io::ApproveFrom, Self::Env> {
            self.pending_call((owner, spender, value))
        }
        fn burn(
            &mut self,
            from: ActorId,
            value: U256,
        ) -> sails_rs::client::PendingCall<io::Burn, Self::Env> {
            self.pending_call((from, value))
        }
        fn exit(
            &mut self,
            inheritor: ActorId,
        ) -> sails_rs::client::PendingCall<io::Exit, Self::Env> {
            self.pending_call((inheritor,))
        }
        fn mint(
            &mut self,
            to: ActorId,
            value: U256,
        ) -> sails_rs::client::PendingCall<io::Mint, Self::Env> {
            self.pending_call((to, value))
        }
        fn pause(&mut self) -> sails_rs::client::PendingCall<io::Pause, Self::Env> {
            self.pending_call(())
        }
        fn resume(&mut self) -> sails_rs::client::PendingCall<io::Resume, Self::Env> {
            self.pending_call(())
        }
        fn set_expiry_period(
            &mut self,
            period: u32,
        ) -> sails_rs::client::PendingCall<io::SetExpiryPeriod, Self::Env> {
            self.pending_call((period,))
        }
        fn is_paused(&self) -> sails_rs::client::PendingCall<io::IsPaused, Self::Env> {
            self.pending_call(())
        }
    }

    pub mod io {
        use super::*;
        sails_rs::io_struct_impl!(AppendAllowancesShard (capacity: u32) -> ());
        sails_rs::io_struct_impl!(AppendBalancesShard (capacity: u32) -> ());
        sails_rs::io_struct_impl!(ApproveFrom (owner: ActorId, spender: ActorId, value: U256) -> bool);
        sails_rs::io_struct_impl!(Burn (from: ActorId, value: U256) -> ());
        sails_rs::io_struct_impl!(Exit (inheritor: ActorId) -> ());
        sails_rs::io_struct_impl!(Mint (to: ActorId, value: U256) -> ());
        sails_rs::io_struct_impl!(Pause () -> ());
        sails_rs::io_struct_impl!(Resume () -> ());
        sails_rs::io_struct_impl!(SetExpiryPeriod (period: u32) -> ());
        sails_rs::io_struct_impl!(IsPaused () -> bool);
    }

    #[cfg(not(target_arch = "wasm32"))]
    pub mod events {
        use super::*;
        #[derive(PartialEq, Debug, Encode, Decode)]
        #[codec(crate = sails_rs::scale_codec)]
        pub enum VftAdminEvents {
            BurnerTookPlace,
            MinterTookPlace,
            ExpiryPeriodChanged(u32),
            Exited(ActorId),
            Paused,
            Resumed,
        }
        impl sails_rs::client::Event for VftAdminEvents {
            const EVENT_NAMES: &'static [Route] = &[
                "BurnerTookPlace",
                "MinterTookPlace",
                "ExpiryPeriodChanged",
                "Exited",
                "Paused",
                "Resumed",
            ];
        }
        impl sails_rs::client::ServiceWithEvents for VftAdminImpl {
            type Event = VftAdminEvents;
        }
    }
}

pub mod vft_extension {
    use super::*;
    pub trait VftExtension {
        type Env: sails_rs::client::GearEnv;
        fn allocate_next_allowances_shard(
            &mut self,
        ) -> sails_rs::client::PendingCall<io::AllocateNextAllowancesShard, Self::Env>;
        fn allocate_next_balances_shard(
            &mut self,
        ) -> sails_rs::client::PendingCall<io::AllocateNextBalancesShard, Self::Env>;
        fn remove_expired_allowance(
            &mut self,
            owner: ActorId,
            spender: ActorId,
        ) -> sails_rs::client::PendingCall<io::RemoveExpiredAllowance, Self::Env>;
        fn transfer_all(
            &mut self,
            to: ActorId,
        ) -> sails_rs::client::PendingCall<io::TransferAll, Self::Env>;
        fn transfer_all_from(
            &mut self,
            from: ActorId,
            to: ActorId,
        ) -> sails_rs::client::PendingCall<io::TransferAllFrom, Self::Env>;
        fn allowance_of(
            &self,
            owner: ActorId,
            spender: ActorId,
        ) -> sails_rs::client::PendingCall<io::AllowanceOf, Self::Env>;
        fn allowances(
            &self,
            cursor: u32,
            len: u32,
        ) -> sails_rs::client::PendingCall<io::Allowances, Self::Env>;
        fn balance_of(
            &self,
            account: ActorId,
        ) -> sails_rs::client::PendingCall<io::BalanceOf, Self::Env>;
        fn balances(
            &self,
            cursor: u32,
            len: u32,
        ) -> sails_rs::client::PendingCall<io::Balances, Self::Env>;
        fn expiry_period(&self) -> sails_rs::client::PendingCall<io::ExpiryPeriod, Self::Env>;
        fn unused_value(&self) -> sails_rs::client::PendingCall<io::UnusedValue, Self::Env>;
    }
    pub struct VftExtensionImpl;
    impl<E: sails_rs::client::GearEnv> VftExtension for sails_rs::client::Service<VftExtensionImpl, E> {
        type Env = E;
        fn allocate_next_allowances_shard(
            &mut self,
        ) -> sails_rs::client::PendingCall<io::AllocateNextAllowancesShard, Self::Env> {
            self.pending_call(())
        }
        fn allocate_next_balances_shard(
            &mut self,
        ) -> sails_rs::client::PendingCall<io::AllocateNextBalancesShard, Self::Env> {
            self.pending_call(())
        }
        fn remove_expired_allowance(
            &mut self,
            owner: ActorId,
            spender: ActorId,
        ) -> sails_rs::client::PendingCall<io::RemoveExpiredAllowance, Self::Env> {
            self.pending_call((owner, spender))
        }
        fn transfer_all(
            &mut self,
            to: ActorId,
        ) -> sails_rs::client::PendingCall<io::TransferAll, Self::Env> {
            self.pending_call((to,))
        }
        fn transfer_all_from(
            &mut self,
            from: ActorId,
            to: ActorId,
        ) -> sails_rs::client::PendingCall<io::TransferAllFrom, Self::Env> {
            self.pending_call((from, to))
        }
        fn allowance_of(
            &self,
            owner: ActorId,
            spender: ActorId,
        ) -> sails_rs::client::PendingCall<io::AllowanceOf, Self::Env> {
            self.pending_call((owner, spender))
        }
        fn allowances(
            &self,
            cursor: u32,
            len: u32,
        ) -> sails_rs::client::PendingCall<io::Allowances, Self::Env> {
            self.pending_call((cursor, len))
        }
        fn balance_of(
            &self,
            account: ActorId,
        ) -> sails_rs::client::PendingCall<io::BalanceOf, Self::Env> {
            self.pending_call((account,))
        }
        fn balances(
            &self,
            cursor: u32,
            len: u32,
        ) -> sails_rs::client::PendingCall<io::Balances, Self::Env> {
            self.pending_call((cursor, len))
        }
        fn expiry_period(&self) -> sails_rs::client::PendingCall<io::ExpiryPeriod, Self::Env> {
            self.pending_call(())
        }
        fn unused_value(&self) -> sails_rs::client::PendingCall<io::UnusedValue, Self::Env> {
            self.pending_call(())
        }
    }

    pub mod io {
        use super::*;
        sails_rs::io_struct_impl!(AllocateNextAllowancesShard () -> bool);
        sails_rs::io_struct_impl!(AllocateNextBalancesShard () -> bool);
        sails_rs::io_struct_impl!(RemoveExpiredAllowance (owner: ActorId, spender: ActorId) -> bool);
        sails_rs::io_struct_impl!(TransferAll (to: ActorId) -> bool);
        sails_rs::io_struct_impl!(TransferAllFrom (from: ActorId, to: ActorId) -> bool);
        sails_rs::io_struct_impl!(AllowanceOf (owner: ActorId, spender: ActorId) -> Option<(U256,u32,)>);
        sails_rs::io_struct_impl!(Allowances (cursor: u32, len: u32) -> Vec<((ActorId,ActorId,),(U256,u32,),)>);
        sails_rs::io_struct_impl!(BalanceOf (account: ActorId) -> Option<U256>);
        sails_rs::io_struct_impl!(Balances (cursor: u32, len: u32) -> Vec<(ActorId,U256,)>);
        sails_rs::io_struct_impl!(ExpiryPeriod () -> u32);
        sails_rs::io_struct_impl!(UnusedValue () -> U256);
    }
}

pub mod vft_metadata {
    use super::*;
    pub trait VftMetadata {
        type Env: sails_rs::client::GearEnv;
        /// Returns the number of decimals of the VFT.
        fn decimals(&self) -> sails_rs::client::PendingCall<io::Decimals, Self::Env>;
        /// Returns the name of the VFT.
        fn name(&self) -> sails_rs::client::PendingCall<io::Name, Self::Env>;
        /// Returns the symbol of the VFT.
        fn symbol(&self) -> sails_rs::client::PendingCall<io::Symbol, Self::Env>;
    }
    pub struct VftMetadataImpl;
    impl<E: sails_rs::client::GearEnv> VftMetadata for sails_rs::client::Service<VftMetadataImpl, E> {
        type Env = E;
        fn decimals(&self) -> sails_rs::client::PendingCall<io::Decimals, Self::Env> {
            self.pending_call(())
        }
        fn name(&self) -> sails_rs::client::PendingCall<io::Name, Self::Env> {
            self.pending_call(())
        }
        fn symbol(&self) -> sails_rs::client::PendingCall<io::Symbol, Self::Env> {
            self.pending_call(())
        }
    }

    pub mod io {
        use super::*;
        sails_rs::io_struct_impl!(Decimals () -> u8);
        sails_rs::io_struct_impl!(Name () -> String);
        sails_rs::io_struct_impl!(Symbol () -> String);
    }
}

pub mod vft_native_exchange {
    use super::*;
    pub trait VftNativeExchange {
        type Env: sails_rs::client::GearEnv;
        fn burn(&mut self, value: U256) -> sails_rs::client::PendingCall<io::Burn, Self::Env>;
        fn burn_all(&mut self) -> sails_rs::client::PendingCall<io::BurnAll, Self::Env>;
        fn mint(&mut self) -> sails_rs::client::PendingCall<io::Mint, Self::Env>;
    }
    pub struct VftNativeExchangeImpl;
    impl<E: sails_rs::client::GearEnv> VftNativeExchange
        for sails_rs::client::Service<VftNativeExchangeImpl, E>
    {
        type Env = E;
        fn burn(&mut self, value: U256) -> sails_rs::client::PendingCall<io::Burn, Self::Env> {
            self.pending_call((value,))
        }
        fn burn_all(&mut self) -> sails_rs::client::PendingCall<io::BurnAll, Self::Env> {
            self.pending_call(())
        }
        fn mint(&mut self) -> sails_rs::client::PendingCall<io::Mint, Self::Env> {
            self.pending_call(())
        }
    }

    pub mod io {
        use super::*;
        sails_rs::io_struct_impl!(Burn (value: U256) -> ());
        sails_rs::io_struct_impl!(BurnAll () -> ());
        sails_rs::io_struct_impl!(Mint () -> ());
    }
}

pub mod vft_native_exchange_admin {
    use super::*;
    pub trait VftNativeExchangeAdmin {
        type Env: sails_rs::client::GearEnv;
        fn burn_from(
            &mut self,
            from: ActorId,
            value: U256,
        ) -> sails_rs::client::PendingCall<io::BurnFrom, Self::Env>;
    }
    pub struct VftNativeExchangeAdminImpl;
    impl<E: sails_rs::client::GearEnv> VftNativeExchangeAdmin
        for sails_rs::client::Service<VftNativeExchangeAdminImpl, E>
    {
        type Env = E;
        fn burn_from(
            &mut self,
            from: ActorId,
            value: U256,
        ) -> sails_rs::client::PendingCall<io::BurnFrom, Self::Env> {
            self.pending_call((from, value))
        }
    }

    pub mod io {
        use super::*;
        sails_rs::io_struct_impl!(BurnFrom (from: ActorId, value: U256) -> ());
    }

    #[cfg(not(target_arch = "wasm32"))]
    pub mod events {
        use super::*;
        #[derive(PartialEq, Debug, Encode, Decode)]
        #[codec(crate = sails_rs::scale_codec)]
        pub enum VftNativeExchangeAdminEvents {
            FailedMint { to: ActorId, value: U256 },
        }
        impl sails_rs::client::Event for VftNativeExchangeAdminEvents {
            const EVENT_NAMES: &'static [Route] = &["FailedMint"];
        }
        impl sails_rs::client::ServiceWithEvents for VftNativeExchangeAdminImpl {
            type Event = VftNativeExchangeAdminEvents;
        }
    }
}
